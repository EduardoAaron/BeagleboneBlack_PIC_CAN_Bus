CCS PCH C Compiler, Version 5.025, 5967               27-feb.-16 15:41

               Filename:   C:\Users\Edu\Documents\Electronica\CAN\BBB_PIC_CAN\BBB_PIC_CAN.X\build\default\production\main.lst

               ROM used:   1340 bytes (4%)
                           Largest free fragment is 31428
               RAM used:   13 (0%) at main() level
                           37 (1%) worst case
               Stack used: 1 locations
               Stack size: 31

*
0000:  GOTO   04BE
.................... /*  
....................  * File:   main.c 
....................  * Author: Eduardo Aarón Fernández Orallo 
....................  * 
....................  * Created on 23 de febrero de 2016, 22:44 
....................  */ 
....................  
.................... #include <18F25K80.h> 
.................... //////////// Standard Header file for the PIC18F25K80 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F25K80 
....................  
.................... #list 
....................  
.................... #device ADC=16 
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES CANB                     //CANTX and CANRX pins are located on RB2 and RB3 
....................  
.................... #use delay(internal=64000000) 
*
0496:  CLRF   FEA
0498:  MOVLW  0D
049A:  MOVWF  FE9
049C:  MOVF   FEF,W
049E:  BZ    04BC
04A0:  MOVLW  14
04A2:  MOVWF  01
04A4:  CLRF   00
04A6:  DECFSZ 00,F
04A8:  BRA    04A6
04AA:  DECFSZ 01,F
04AC:  BRA    04A4
04AE:  MOVLW  BF
04B0:  MOVWF  00
04B2:  DECFSZ 00,F
04B4:  BRA    04B2
04B6:  BRA    04B8
04B8:  DECFSZ FEF,F
04BA:  BRA    04A0
04BC:  RETURN 0
....................  
.................... //Configure CAN bus speed for 1Mbs 
.................... #define CAN_USE_EXTENDED_ID FALSE 
.................... #define CAN_BRG_SEG_2_PHASE_TS TRUE   
.................... #define CAN_BRG_PRESCALAR 1  
.................... #define CAN_BRG_SYNCH_JUMP_WIDTH 0  
.................... #define CAN_BRG_PROPAGATION_TIME 7  
.................... #define CAN_BRG_PHASE_SEGMENT_1 0  
.................... #define CAN_BRG_PHASE_SEGMENT_2 5  
.................... #define CAN_BRG_WAKE_FILTER TRUE  
.................... #define CAN_BRG_SAM FALSE 
....................  
.................... #include <can-18F4580.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18F4580.c                            //// 
.................... //// CAN Library routines for Microchip's PIC18Cxx8 and 18Fxx8 line  //// 
.................... ////                                                                 //// 
.................... //// This library provides the following functions:                  //// 
.................... ////  (for more information on these functions see the comment       //// 
.................... ////   header above each function)                                   //// 
.................... ////                                                                 //// 
.................... ////    can_init - Configures the PIC18F4580 CAN peripheral*         //// 
.................... ////                                                                 //// 
.................... ////    can_set_baud - Sets the baud rate control registers*         //// 
.................... ////                                                                 //// 
.................... ////    can_set_mode - Sets the CAN module into a specific mode*     //// 
.................... ////                                                                 //// 
.................... ////     can_set_functional_mode - Sets the function mode            //// 
.................... ////                                                                 //// 
.................... ////    can_set_id - Sets the standard and extended ID*              //// 
.................... ////                                                                 //// 
.................... ////     can_set_extended_id - Sets only extended ID                 //// 
.................... ////                                                                 //// 
.................... ////     can_set_standard_id - Sets only standard ID                 //// 
.................... ////                                                                 //// 
.................... ////    can_get_id - Gets the standard and extended ID*              //// 
.................... ////                                                                 //// 
.................... ////     can_get_extended_id - Gets only extended ID                 //// 
.................... ////                                                                 //// 
.................... ////     can_get_standard_id - Gets only standard ID                 //// 
.................... ////                                                                 //// 
.................... ////    can_putd - Sends a message/request with specified ID*        //// 
.................... ////                                                                 //// 
.................... ////    can_getd - Returns specified message/request and ID*         //// 
.................... ////                                                                 //// 
.................... ////    can_kbhit - Returns true if there is data in one of the*     //// 
.................... ////                receive buffers                                  //// 
.................... ////                                                                 //// 
.................... ////    can_tbe - Returns true if the transmit buffer is ready to    //// 
.................... ////              send more data*                                    //// 
.................... ////                                                                 //// 
.................... ////    can_abort - Aborts all pending transmissions*                //// 
.................... ////                                                                 //// 
.................... ////    can_enable_b_transfer - enables buffer as transmitter        //// 
.................... ////                                                                 //// 
.................... ////     can_enable_b_receiver - enables buffer as receiver          //// 
.................... ////                                                                 //// 
.................... ////     can_enable_rtr - enables transmit buffer as Auto-rtr        //// 
.................... ////                                                                 //// 
.................... ////     can_disable_rtr - disables transmit buffer as Auto-rtr      //// 
.................... ////                                                                 //// 
.................... ////    can_load_rtr - loads an Auto-rtr buffer with data            //// 
.................... ////                                                                 //// 
.................... ////    can_enable_filter - enables one of 15 filters                //// 
.................... ////                                                                 //// 
.................... ////    can_disable_filter - disables one of the 15 filters          //// 
.................... ////                                                                 //// 
.................... ////    can_associate_filter_to_buffer - associates a filter with    //// 
.................... ////                                      a receive buffer           //// 
.................... ////                                                                 //// 
.................... ////     can_associate_filter_to_mask - associates a filter with a   //// 
.................... ////                                    mask                         //// 
.................... ////                                                                 //// 
.................... ////     can_fifo_getd - retrieve data in FIFO mode (2)              //// 
.................... ////                                                                 //// 
.................... ////     can_t0_putd                                                 //// 
.................... ////     can_t1_putd                                                 //// 
.................... ////     can_t2_putd                                                 //// 
.................... ////     can_b0_putd                                                 //// 
.................... ////     can_b1_putd                                                 //// 
.................... ////     can_b2_putd                                                 //// 
.................... ////     can_b3_putd                                                 //// 
.................... ////     can_b4_putd                                                 //// 
.................... ////     can_b5_putd                                                 //// 
.................... ////     can_b6_putd                                                 //// 
.................... ////     can_b7_putd - place data in a specific buffer               //// 
.................... ////                                                                 //// 
.................... //// PIN_B3 is CANRX, and PIN_B2 is CANTX.  You will need a CAN      //// 
.................... //// transceiver to connect these pins to CANH and CANL bus lines.   //// 
.................... ////                                                                 //// 
.................... //// CCS provides an example, ex_can.c, which shows how to use this  //// 
.................... //// library.                                                        //// 
.................... ////                                                                 //// 
.................... //// * Designates functions that work in legacy mode                 //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History                                                 //// 
.................... ////                                                                 //// 
.................... ////  Jul 27 04 - can_init() uses CAN_USE_EXTENDED_ID instead of     //// 
.................... ////              setting all RX filters to extended.                //// 
.................... ////                                                                 //// 
.................... ////  Feb 24 04 - can_get_id() fixed for EID<18:20>.                 //// 
.................... ////                                                                 //// 
.................... ////  Mar 30 09 - added CANTX2 code for PIC18F6585/8585/6680/8680    //// 
.................... ////                                                                 //// 
.................... ////  Sep 29 09 - fixed problems with enhanced mode                  //// 
.................... ////                                                                 //// 
.................... ////  Oct 08 09 - can_getd() filter hit fixed of enhanced mode       //// 
.................... ////                                                                 //// 
.................... ////  Jan 21 10 - changed variable types to unsigned incase compiled //// 
.................... ////              with #device ANSI, which makes variables signed    //// 
.................... ////                                                                 //// 
.................... ////  Apr 13 10 - changed can_set_functional_mode() to restore       //// 
.................... ////              operating mode to same mode when called, instead   //// 
.................... ////              of setting it to normal mode                       //// 
.................... ////                                                                 //// 
.................... ////  Mar 24 11 - updated for new PIC18FxxK80 chips                  //// 
.................... ////                                                                 //// 
.................... ////  Jan 10 13 - Fixed an issue with can_associate_filter_to_mask() //// 
.................... ////              and can_associate_filter_to_buffer() functions     //// 
.................... ////              using incorrect register addresses for K80 chips,  //// 
.................... ////              and updated can_init() function to setup correct   //// 
.................... ////              tris register for PIC being used.                  //// 
.................... ////                                                                 //// 
.................... ////  Oct 03 13 - Updated can_getd() and can_fifo_getd() functions   //// 
.................... ///               to clear overflow flag when in mode 1 and 2.       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #include <can-18F4580.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                        can-18F4580.h                            //// 
.................... ////                                                                 //// 
.................... //// Prototypes, definitions, defines and macros used for and with   //// 
.................... //// the CCS CAN library for PIC18Fxx8 and PIC18Cxx8.                //// 
.................... ////                                                                 //// 
.................... //// (see can-18F4580.c)                                             //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __CCS_CAN18F4580_LIB_DEFINES__ 
.................... #define __CCS_CAN18F4580_LIB_DEFINES__ 
....................  
.................... #ifndef CAN_DO_DEBUG 
....................  #define CAN_DO_DEBUG FALSE 
.................... #endif 
....................  
.................... #IFNDEF CAN_USE_EXTENDED_ID 
....................   #define CAN_USE_EXTENDED_ID         TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_SYNCH_JUMP_WIDTH 
....................   #define CAN_BRG_SYNCH_JUMP_WIDTH  0  //synchronized jump width (def: 1 x Tq) 
.................... #ENDIF 
....................  
.................... #IFNDEF CAN_BRG_PRESCALAR 
....................   #define CAN_BRG_PRESCALAR  4  //baud rate generator prescalar (def: 4) ( Tq = (2 x (PRE + 1))/Fosc ) 
.................... #ENDIF 
....................  
.................... #ifndef CAN_BRG_SEG_2_PHASE_TS 
....................  #define CAN_BRG_SEG_2_PHASE_TS   TRUE //phase segment 2 time select bit (def: freely programmable) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_SAM 
....................  #define CAN_BRG_SAM 0 //sample of the can bus line (def: bus line is sampled 1 times prior to sample point) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_1 
....................  #define CAN_BRG_PHASE_SEGMENT_1  5 //phase segment 1 (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PROPAGATION_TIME 
....................  #define CAN_BRG_PROPAGATION_TIME 2 //propagation time select (def: 3 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_WAKE_FILTER 
....................  #define CAN_BRG_WAKE_FILTER FALSE   //selects can bus line filter for wake up bit 
.................... #endif 
....................  
.................... #ifndef CAN_BRG_PHASE_SEGMENT_2 
....................  #define CAN_BRG_PHASE_SEGMENT_2 5 //phase segment 2 time select (def: 6 x Tq) 
.................... #endif 
....................  
.................... #ifndef CAN_USE_RX_DOUBLE_BUFFER 
....................  #define CAN_USE_RX_DOUBLE_BUFFER TRUE   //if buffer 0 overflows, do NOT use buffer 1 to put buffer 0 data 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_DRIVE_HIGH 
....................  #define CAN_ENABLE_DRIVE_HIGH 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CAN_CAPTURE 
....................  #define CAN_ENABLE_CAN_CAPTURE 0 
.................... #endif 
....................  
.................... #ifndef CAN_ENABLE_CANTX2           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_ENABLE_CANTX2 0      // 0 CANTX2 disabled, 1 CANTX2 enabled 
.................... #endif 
....................  
.................... #ifndef CAN_CANTX2_SOURCE           // added 03/30/09 for PIC18F6585/8585/6680/8680 
....................    #define CAN_CANTX2_SOURCE 0      // 0 source is invert of CANTX1, 1 source is CAN Clock 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////////  CAN Control Register ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_OP_MODE {   CAN_OP_CONFIG=4, 
....................                      CAN_OP_LISTEN=3, 
....................                      CAN_OP_LOOPBACK=2, 
....................                      CAN_OP_DISABLE=1, 
....................                      CAN_OP_NORMAL=0 }; 
....................  
.................... enum CAN_FUN_OP_MODE { CAN_FUN_OP_LEGACY=0, 
....................                        CAN_FUN_OP_ENHANCED=1, 
....................                        CAN_FUN_OP_ENHANCED_FIFO=2 }; 
....................  
.................... enum CAN_WIN_ADDRESS {   CAN_WIN_RX0=0, 
....................                         CAN_WIN_RX1=5, 
....................                         CAN_WIN_TX0=4, 
....................                         CAN_WIN_TX1=3, 
....................                         CAN_WIN_TX2=2 }; 
....................  
.................... enum CAN_FIFO_READ {   CAN_FIFO_MB7=7, 
....................                      CAN_FIFO_MB6=6, 
....................                      CAN_FIFO_MB5=5, 
....................                      CAN_FIFO_MB4=4, 
....................                      CAN_FIFO_MB3=3, 
....................                      CAN_FIFO_MB2=2, 
....................                      CAN_FIFO_MB1=1, 
....................                      CAN_FIFO_MB0=0 }; 
....................  
.................... // Control register configurations for modes 0, 1, and 2 
.................... //can control 
.................... struct { 
....................    int1 void0;              //0 
....................    CAN_WIN_ADDRESS win:3;   //1:3   //window address bits 
....................    int1 abat;               //4     //abort all pending transmissions 
....................    CAN_OP_MODE reqop:3;     //5:7   //request can operation mode bits 
.................... } CANCON; 
.................... #byte CANCON = getenv("SFR:CANCON")    //0xF6F 
....................  
.................... //can control for mode 1 
.................... struct { 
....................    int1 void3210:4;     //0123 
....................    int1 abat;           //4    abort all pending transmissions 
....................    CAN_OP_MODE reqop:3; //5:7  request can operation mode bits 
.................... } CANCON_MODE_1; 
.................... #byte CANCON_MODE_1 = getenv("SFR:CANCON")      //0xF6F 
....................  
.................... // can control for mode 2 
.................... struct { 
....................    CAN_FIFO_READ fp:4;  //0:3 points to message buffer to read 
....................    int1 abat;           //4   abort 
....................    CAN_OP_MODE reqop:3; //5:7 request can operation mode bits 
.................... } CANCON_MODE_2; 
.................... #byte CANCON_MODE_2 = getenv("SFR:CANCON")      //0xF6F 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////  ECAN control register /////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum ECAN_MODE { ECAN_LEGACY=0, ECAN_ENHANCED_LEGACY=1, ECAN_ENHANCED_FIFO=2 }; 
.................... enum ECAN_WINDOW_ADDRESS { AF012_BRGCON23=0, 
....................                            AF345_BRGCON1_=1, 
....................                            AFM_ERROR_ICON=2, 
....................                            TX0=3, 
....................                            TX1=4, 
....................                            TX2=5, 
....................                            AF678=6, 
....................                            AccF91011=7, 
....................                            AccF121314=8, 
....................                            AccF15=9, 
....................                            RXINT01=15, 
....................                            RX0=16, 
....................                            RX1=17, 
....................                            TXRX0=18, 
....................                            TXRX1=19, 
....................                            TXRX2=20, 
....................                            TXRX3=21, 
....................                            TXRX4=22, 
....................                            TXRX5=23 }; 
....................  
.................... //ecan control register mode 1, 2, & 3 
.................... struct { 
....................    ECAN_WINDOW_ADDRESS ewin:5;   //0:4 access bank map 
....................    int1 fifowm;                  //5   FIFO high water mark 
....................    ECAN_MODE mdsel:2;            //6:7 Mode select bits 
.................... } ECANCON; 
.................... #byte ECANCON = getenv("SFR:ECANCON")     //0xF77 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////////////  CAN Status Register  /////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_INT_CODE {   CAN_INT_WAKEUP=7, 
....................                      CAN_INT_RX0=6, 
....................                      CAN_INT_RX1=5, 
....................                      CAN_INT_TX0=4, 
....................                      CAN_INT_TX1=3, 
....................                      CAN_INT_TX2=2, 
....................                      CAN_INT_ERROR=1, 
....................                      CAN_INT_NO=0}; 
....................  
.................... enum CAN_EINT_CODE {   CAN_EINT_NO=0, 
....................                      CAN_EINT_ERROR=2, 
....................                      CAN_EINT_TX2=4, 
....................                      CAN_EINT_TX1=6, 
....................                      CAN_EINT_TX0=8, 
....................                      CAN_EINT_RX1=17, 
....................                      CAN_EINT_RX0=16, 
....................                      CAN_EINT_WAKEUP=14, 
....................                      CAN_EINT_RXB0=16, 
....................                      CAN_EINT_RXB1=17, 
....................                      CAN_EINT_B0=18, 
....................                      CAN_EINT_B1=19, 
....................                      CAN_EINT_B2=20, 
....................                      CAN_EINT_B3=21, 
....................                      CAN_EINT_B4=22, 
....................                      CAN_EINT_B5=23 }; 
....................  
.................... //can status register READ-ONLY 
.................... struct { 
....................    int1 void0;             //0 
....................    CAN_INT_CODE icode:3;   //1:3 //interrupt code 
....................    int1 void4;             //4 
....................    CAN_OP_MODE opmode:3;   //5:7 //operation mode status 
.................... } CANSTAT; 
.................... #byte CANSTAT = getenv("SFR:CANSTAT")     //0xF6E 
....................  
.................... //can status register mode 1 
.................... struct { 
....................    CAN_EINT_CODE eicode:5;   //0:4 interrupt code 
....................    CAN_OP_MODE opmode:3;     //5:7 operation mode status 
.................... } CANSTAT_MODE_1; 
.................... #byte CANSTAT_MODE_1 = getenv("SFR:CANSTAT")    //0xF6E 
....................  
.................... //can status register mode 2 
.................... struct { 
....................    CAN_EINT_CODE eicode:5; 
....................    CAN_OP_MODE opmode:3; 
.................... }   CANSTAT_MODE_2; 
.................... #byte CANSTAT_MODE_2 = getenv("SFR:CANSTAT")    //0xF6E 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ////////////////////  Communication Status Register  /////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //communication status register READ-ONLY 
.................... struct { 
....................    int1 ewarn;   //0 //error warning 
....................    int1 rxwarn;  //1 //receiver warning 
....................    int1 txwarn;  //2 //transmitter warning 
....................    int1 rxbp;    //3 //receiver bus passive 
....................    int1 txbp;    //4 //transmitter bus passive bit 
....................    int1 txbo;    //5 //transmitter bus off 
....................    int1 rx1ovfl; //6 //receive buffer 1 overflow 
....................    int1 rx0ovfl; //7 //receive buffer 0 overflow 
.................... } COMSTAT; 
.................... #byte COMSTAT = getenv("SFR:COMSTAT")     //0xF74 
....................  
.................... //communication status register mode 1 
.................... struct { 
....................    int1 ewarn;   //0 error warning 
....................    int1 rxwarn;  //1 receiver warning 
....................    int1 txwarn;  //2 transmitter warning 
....................    int1 rxbp;    //3 receiver bus passive 
....................    int1 txbp;    //4 transmitter bus passive bit 
....................    int1 txbo;    //5 transmitter bus off 
....................    int1 rxnovfl; //6 receive buffer n overflow 
....................    int1 void7;   //7 
.................... } COMSTAT_MODE_1; 
.................... #byte COMSTAT_MODE_1 = getenv("SFR:COMSTAT")       //0xF74 
....................  
.................... //communication status register mode 2 
.................... struct { 
....................    int1 ewarn;     //0 error warning 
....................    int1 rxwarn;    //1 receiver warning 
....................    int1 txwarn;    //2 transmitter warning 
....................    int1 rxbp;      //3 receiver bus passive 
....................    int1 txbp;      //4 transmitter bus passive bit 
....................    int1 txbo;      //5 transmitter bus off 
....................    int1 rxnovfl;   //6 receive buffer n overflow 
....................    int1 fifoempty; //7 FIFO not empty bit 
.................... } COMSTAT_MODE_2; 
.................... #byte COMSTAT_MODE_2 = getenv("SFR:COMSTAT")       //0xF74 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Baud Control Registers ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //baud rate control register 1 
.................... struct { 
....................    int brp:6;   //0:5 //baud rate prescalar 
....................    int sjw:2;   //6:7 //synchronized jump width 
.................... } BRGCON1; 
.................... #byte BRGCON1 = getenv("SFR:BRGCON1")     //0xF70 
....................  
.................... //baud rate control register 2 
.................... struct { 
....................    int prseg:3;   //0:2 //propagation time select 
....................    int seg1ph:3;  //3:5 //phase segment 1 
....................    int1 sam;      //6   //sample of the can bus line 
....................    int1 seg2phts; //7   //phase segment 2 time select 
.................... } BRGCON2; 
.................... #byte BRGCON2 = getenv("SFR:BRGCON2")     //0xF71 
....................  
.................... //baud rate control register 3 
.................... struct { 
....................    int seg2ph:3;  //0:2 //phase segment 2 time select 
....................    int void543:3; //3:5 
....................    int1 wakfil;   //6   //selects can bus line filter for wake-up 
....................    int1 void7;    //7 
.................... } BRGCON3; 
.................... #byte BRGCON3 = getenv("SFR:BRGCON3")     //0xF72 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //can i/o control register 
.................... struct { 
....................    int void3210:4;  //0:3 
....................    int1 cancap;     //4 //can message receive capture 
....................    int1 endrhi;     //5 //enable drive high 
....................    int1 tx2en;      //6 //CANTX2 pin enable bit          //added 3/24/09 for PIC18F6585/8585/6680/8680 
....................    int1 tx2src;     //7 //CANTX2 pin data source bit     //added 3/24/09 for PIC18F6585/8585/6680/8680 
.................... } CIOCON; 
.................... #byte CIOCON = getenv("SFR:CIOCON")    //0xF73 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Transmit Control Registers ///////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //transmit buffer n control register for mode 0 
.................... struct txbNcon_struct { 
....................    int  txpri:2;  //0:1 //transmit priority bits 
....................    int1 void2;    //2 
....................    int1 txreq;    //3   //transmit request status (clear to request message abort) 
....................    int1 txerr;    //4   //transmission error detected 
....................    int1 txlarb;   //5   //transmission lost arbitration status 
....................    int1 txabt;    //6   //transmission aborted status 
....................    int1 void7; 
.................... }; 
.................... struct txbNcon_struct TXB0CON; 
.................... struct txbNcon_struct TXB1CON; 
.................... struct txbNcon_struct TXB2CON; 
.................... struct txbNcon_struct TXBaCON; 
.................... #byte TXB0CON = getenv("SFR:TXB0CON")      //0xF40 
.................... #byte TXB1CON = getenv("SFR:TXB1CON")      //0xF30 
.................... #byte TXB2CON = getenv("SFR:TXB2CON")      //0xF20 
.................... #byte TXBaCON = 0xF60 //txbXcon when in the access bank 
....................  
....................  
.................... //transmit buffer n control register for mode 1 & 2 
.................... struct txbNconm12_struct { 
....................    int  txpri:2;  //0:1 transmit priority bits 
....................    int1 void2;    //2 
....................    int1 txreq;    //3   transmit request status (clear to request message abort) 
....................    int1 txerr;    //4   transmission error detected 
....................    int1 txlarb;   //5   transmission lost arbitration status 
....................    int1 txabt;    //6   transmission aborted status 
....................    int1 txbif;    //7   transmission complete, ready for new data 
.................... }; 
.................... struct txbNconm12_struct TXB0CON_MODE_1; 
.................... struct txbNconm12_struct TXB0CON_MODE_2; 
.................... struct txbNconm12_struct TXB1CON_MODE_1; 
.................... struct txbNconm12_struct TXB1CON_MODE_2; 
.................... struct txbNconm12_struct TXB2CON_MODE_1; 
.................... struct txbNconm12_struct TXB2CON_MODE_2; 
.................... struct txbNconm12_struct TXBaCON_MODE_1; 
.................... struct txbNconm12_struct TXBaCON_MODE_2; 
.................... #byte TXB0CON_MODE_1 = getenv("SFR:TXB0CON")     //0xF40 
.................... #byte TXB0CON_MODE_2 = getenv("SFR:TXB0CON")     //0xF40 
.................... #byte TXB1CON_MODE_1 = getenv("SFR:TXB1CON")     //0xF30 
.................... #byte TXB1CON_MODE_2 = getenv("SFR:TXB1CON")     //0xF30 
.................... #byte TXB2CON_MODE_1 = getenv("SFR:TXB2CON")     //0xF20 
.................... #byte TXB2CON_MODE_2 = getenv("SFR:TXB2CON")     //0xF20 
.................... #byte TXBaCON_MODE_1=0xF60 
.................... #byte TXBaCON_MODE_2=0xF60 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //transmit buffer n standard identifier 
.................... #byte TXB0SIDH = getenv("SFR:TXB0SIDH")      //0xF41 
.................... #byte TXB0SIDL = getenv("SFR:TXB0SIDL")      //0xF42 
.................... #byte TXB1SIDH = getenv("SFR:TXB1SIDH")      //0xF31 
.................... #byte TXB1SIDL = getenv("SFR:TXB1SIDL")      //0xF32 
.................... #byte TXB2SIDH = getenv("SFR:TXB2SIDH")      //0xF21 
.................... #byte TXB2SIDL = getenv("SFR:TXB2SIDL")      //0xF22 
....................  
.................... //transmit buffer n extended identifier 
.................... #byte TXB0EIDH = getenv("SFR:TXB0EIDH")      //0xF43 
.................... #byte TXB0EIDL = getenv("SFR:TXB0EIDL")      //0xF44 
.................... #byte TXB1EIDH = getenv("SFR:TXB1EIDH")      //0xF33 
.................... #byte TXB1EIDL = getenv("SFR:TXB1EIDL")      //0xF34 
.................... #byte TXB2EIDH = getenv("SFR:TXB2EIDH")      //0xF23 
.................... #byte TXB2EIDL = getenv("SFR:TXB2EIDL")      //0xF24 
....................  
.................... #define RX0MASK      getenv("SFR:RXM0EIDL")     //0xF1B    //rxm0eidl 
.................... #define RX1MASK      getenv("SFR:RXM1EIDL")     //0xF1F    //rxm1eidl 
.................... #define RX0FILTER0   getenv("SFR:RXF0EIDL")     //0xF03    //rxf0eidl 
.................... #define RX0FILTER1   getenv("SFR:RXF1EIDL")     //0xF07    //rxf1eidl 
.................... #define RX1FILTER2   getenv("SFR:RXF2EIDL")     //0xF0B    //rxf2eidl 
.................... #define RX1FILTER3   getenv("SFR:RXF3EIDL")     //0xF0F    //rxf3eidl 
.................... #define RX1FILTER4   getenv("SFR:RXF4EIDL")     //0xF13    //rxf4eidl 
.................... #define RX1FILTER5   getenv("SFR:RXF5EIDL")     //0xF17    //rxf5eidl 
.................... #define RXB0ID       getenv("SFR:RXB0EIDL")     //0xF64    //rxb0eidl 
.................... #define RXB1ID       getenv("SFR:RXB1EIDL")     //0xF54    //rxb1eidl 
.................... #define TXB0ID       getenv("SFR:TXB0EIDL")     //0xF44    //txb0eidl 
.................... #define TXB1ID       getenv("SFR:TXB1EIDL")     //0xF34    //txb1eidl 
.................... #define TXB2ID       getenv("SFR:TXB2EIDL")     //0xF24    //txb2eidl 
.................... #define B0ID         getenv("SFR:B0EIDL")       //0xE24    //b0eidl 
.................... #define B1ID         getenv("SFR:B1EIDL")       //0xE34    //b1eidl 
.................... #define B2ID         getenv("SFR:B2EIDL")       //0xE44    //b2eidl 
.................... #define B3ID         getenv("SFR:B3EIDL")       //0xE54    //b3eidl 
.................... #define B4ID         getenv("SFR:B4EIDL")       //0xE64    //b4eidl 
.................... #define B5ID         getenv("SFR:B5EIDL")       //0xE74    //b5eidl 
.................... #define TXRXBaID     0xF64 
....................  
.................... //transmit buffer n data byte m 
.................... #byte TXB0D0 = getenv("SFR:TXB0D0")       //0xF46 
.................... #byte TXB0D7 = getenv("SFR:TXB0D7")       //0xF4D 
.................... #byte TXB1D0 = getenv("SFR:TXB1D0")       //0xF36 
.................... #byte TXB1D7 = getenv("SFR:TXB1D7")       //0xF3D 
.................... #byte TXB2D0 = getenv("SFR:TXB2D0")       //0xF26 
.................... #byte TXB2D7 = getenv("SFR:TXB2D7")       //0xF2D 
....................  
.................... //transmit buffer n data length 
.................... struct txbNdlc_struct { 
....................    int dlc:4;    //0:3 
....................    int void54:2; //4:5 
....................    int1 rtr;     //6 //transmission frame remote transmission 
....................    int1 void7;   //7 
.................... }; 
.................... struct txbNdlc_struct TXB0DLC; 
.................... struct txbNdlc_struct TXB1DLC; 
.................... struct txbNdlc_struct TXB2DLC; 
.................... struct txbNdlc_struct TXBaDLC; 
.................... #byte TXB0DLC = getenv("SFR:TXB0DLC")     //0xF45 
.................... #byte TXB1DLC = getenv("SFR:TXB1DLC")     //0xF35 
.................... #byte TXB2DLC = getenv("SFR:TXB2DLC")     //0xF25 
.................... #byte TXBaDLC = 0xF65  //txbXdlc when in the access bank 
....................  
....................  
.................... //transmit error count register 
.................... #byte TXERRCNT = getenv("SFR:TXERRCNT")      //0xF76 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////////// Receive Control Registers ///////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_RX_MODE {CAN_RX_ALL=3, CAN_RX_EXT=2, CAN_RX_STD=1, CAN_RX_VALID=0}; 
.................... enum ECAN_FILTER_HIT {   RXF0=0, RXF1=1, RXF2=2, RXF3=3, RXF4=4, RXF5=5, 
....................                         RXF6=6, RXF7=7, RXF8=8, RXF9=9, RXF10=10, RXF11=11, 
....................                         RXF12=12, RXF13=13, RXF14=14, RXF15=15 }; 
....................  
....................  
.................... //receive buffer 0 control register mode 0 
.................... struct { 
....................    int1 filthit0;      //0   //filter hit 
....................    int1 jtoff;         //1   //jump table offset 
....................    int1 rxb0dben;      //2   //receive buffer 0 double buffer enable 
....................    int1 rxrtrro;       //3   //receive remote transfer request 
....................    int1 void4;         //4 
....................    CAN_RX_MODE rxm:2;  //5:6 //receiver buffer mode 
....................    int1 rxful;         //7   //receive full status 
.................... } RXB0CON; 
.................... #byte RXB0CON = getenv("SFR:RXB0CON")     //0xF60 
....................  
.................... //receive buffer 0 control register mode 1 & 2 
.................... struct rxb01m12con { 
....................    ECAN_FILTER_HIT filthit:5; //1:4 Acceptance filter bits 
....................    int1 rtrro;                //5   remote transmission request bit 
....................    int1 rxm1;                 //6   receive buffer mode 
....................    int1 rxful;                //7   receive full status 
.................... }; 
.................... struct rxb01m12con RXB0CON_MODE_1; 
.................... struct rxb01m12con RXB0CON_MODE_2; 
.................... #byte RXB0CON_MODE_1 = getenv("SFR:RXB0CON")    //0xF60 
.................... #byte RXB0CON_MODE_2 = getenv("SFR:RXB0CON")    //0xF60 
....................  
.................... //receive buffer 1 control register mode 0 
.................... struct { 
....................    int filthit:3;     //0:2 
....................    int1 rxrtrro;      //3   //receive remote transfer request 
....................    int1 void4;        //4 
....................    CAN_RX_MODE rxm:2; //5:6 //receive buffer mode 
....................    int1 rxful;        //7   //receive full 
.................... } RXB1CON; 
.................... #byte   RXB1CON = getenv("SFR:RXB1CON")      //0xF50 
....................  
.................... //receive buffer 1 control register mode 1 & 2 
.................... struct rxb01m12con RXB1CON_MODE_1; 
.................... struct rxb01m12con RXB1CON_MODE_2; 
.................... #byte RXB1CON_MODE_1 = getenv("SFR:RXB1CON")    //0xF50 
.................... #byte RXB1CON_MODE_2 = getenv("SFR:RXB1CON")    //0xF50 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Buffer Select Register ///////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum PROG_BUFFER { B0=0x04 , B1=0x08 , B2=0x10 , B3=0x20 , B4=0x40 , B5=0x80 }; 
....................  
.................... // bsel0 
.................... struct { 
....................    int   void10:2;      //0-1 
....................    int1  b0txen;        //2   //buffer 0 transmit enable bit 
....................    int1  b1txen;        //3   //buffer 1 transmit enable bit 
....................    int1  b2txen;        //4   //buffer 2 transmit enable bit 
....................    int1  b3txen;        //5   //buffer 3 transmit enable bit 
....................    int1  b4txen;        //6   //buffer 4 transmit enable bit 
....................    int1  b5txen;        //7   //buffer 5 transmit enable bit 
.................... } BSEL0; 
.................... #byte BSEL0 = getenv("SFR:BSEL0")      //0xDF8 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// Bn Control Registers /////////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum ECAN_AF { AF0=0  , AF1=1  , AF2=2  , AF3=3  , AF4=4 , 
....................                AF5=5  , AF6=6  , AF7=7  , AF8=8  , AF9=9 , 
....................                AF10=10, AF11=11, AF12=12, AF13=13, AF14=14, 
....................                AF15=15 }; 
....................  
.................... //Bn control register in receive mode 
.................... struct BaCON_recive { 
....................    ECAN_AF filhit:5; //0:4 Acceptance filter bits 
....................    int1 rxrtrro;     //5   Read only remote transmission request 
....................    int1 rxm1;        //6   Receive buffer mode bit 
....................    int1 rxful;       //7   receiver full status bit 
.................... }; 
....................  
.................... //Bn control register in transmit mode 
.................... struct BaCON_transmit { 
....................    int    txpri:2; //0:1 Priority Bits 
....................    int1   rtren;   //2   Automatic Remote Transmission request bit 
....................    int1   txreq;   //3   Transmit request status 
....................    int1   txerr;   //4   Transmission error detected 
....................    int1   txlarb;  //5   Transmission lost arbitration bit 
....................    int1   txabt;   //6   Transmission aborted status bit 
....................    int1   txbif;   //7   Transmit buffer interrupt flag bit 
.................... }; 
....................  
.................... struct BaCON_recive B0CONR; 
.................... struct BaCON_recive B1CONR; 
.................... struct BaCON_recive B2CONR; 
.................... struct BaCON_recive B3CONR; 
.................... struct BaCON_recive B4CONR; 
.................... struct BaCON_recive B5CONR; 
.................... // struct bytes, used for access to specific bits 
.................... #byte B0CONR = getenv("SFR:B0CON")     //0xE20 
.................... #byte B1CONR = getenv("SFR:B1CON")     //0xE30 
.................... #byte B2CONR = getenv("SFR:B2CON")     //0xE40 
.................... #byte B3CONR = getenv("SFR:B3CON")     //0xE50 
.................... #byte B4CONR = getenv("SFR:B4CON")     //0xE60 
.................... #byte B5CONR = getenv("SFR:B5CON")     //0xE70 
.................... // access bytes, used for fast access to the entire byte 
.................... #byte B0CONRA = getenv("SFR:B0CON")    //0xE20 
.................... #byte B1CONRA = getenv("SFR:B1CON")    //0xE30 
.................... #byte B2CONRA = getenv("SFR:B2CON")    //0xE40 
.................... #byte B3CONRA = getenv("SFR:B3CON")    //0xE50 
.................... #byte B4CONRA = getenv("SFR:B4CON")    //0xE60 
.................... #byte B5CONRA = getenv("SFR:B5CON")    //0xE70 
....................  
.................... struct BaCON_transmit B0CONT; 
.................... struct BaCON_transmit B1CONT; 
.................... struct BaCON_transmit B2CONT; 
.................... struct BaCON_transmit B3CONT; 
.................... struct BaCON_transmit B4CONT; 
.................... struct BaCON_transmit B5CONT; 
.................... // struct bytes, used for access to specific bits 
.................... #byte B0CONT = getenv("SFR:B0CON")     //0xE20 
.................... #byte B1CONT = getenv("SFR:B1CON")     //0xE30 
.................... #byte B2CONT = getenv("SFR:B2CON")     //0xE40 
.................... #byte B3CONT = getenv("SFR:B3CON")     //0xE50 
.................... #byte B4CONT = getenv("SFR:B4CON")     //0xE60 
.................... #byte B5CONT = getenv("SFR:B5CON")     //0xE70 
.................... // access bytes, used for fast access to the entire byte 
.................... #byte B0CONTA = getenv("SFR:B0CON")    //0xE20 
.................... #byte B1CONTA = getenv("SFR:B1CON")    //0xE30 
.................... #byte B2CONTA = getenv("SFR:B2CON")    //0xE40 
.................... #byte B3CONTA = getenv("SFR:B3CON")    //0xE50 
.................... #byte B4CONTA = getenv("SFR:B4CON")    //0xE60 
.................... #byte B5CONTA = getenv("SFR:B5CON")    //0xE70 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// B Data Length Code Registers /////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //DLC register for Bn in receive mode 
.................... struct BnDLC_receive { 
....................    int  dlc:4;    //0:3 data length code bits 
....................    int  void45:2; //4:5 
....................    int1 rxrtr;    //6   receiver remote transmission request 
....................    int1 void7;    //7 
.................... }; 
....................  
.................... //DLC register for Bn in transmit mode 
.................... struct BnDLC_transmit { 
....................    int  dlc:4;    //0:3 data length code bits 
....................    int  void45:2; //4:5 
....................    int1 txrtr;    //6   data length code bits 
....................    int1 void7;    //7 
.................... }; 
....................  
.................... struct BnDLC_receive B0DLCR; 
.................... struct BnDLC_receive B1DLCR; 
.................... struct BnDLC_receive B2DLCR; 
.................... struct BnDLC_receive B3DLCR; 
.................... struct BnDLC_receive B4DLCR; 
.................... struct BnDLC_receive B5DLCR; 
.................... #byte B0DLCR = getenv("SFR:B0DLC")     //0xE25 
.................... #byte B1DLCR = getenv("SFR:B1DLC")     //0xE35 
.................... #byte B2DLCR = getenv("SFR:B2DLC")     //0xE45 
.................... #byte B3DLCR = getenv("SFR:B3DLC")     //0xE55 
.................... #byte B4DLCR = getenv("SFR:B4DLC")     //0xE65 
.................... #byte B5DLCR = getenv("SFR:B5DLC")     //0xE75 
....................  
.................... struct BnDLC_transmit B0DLCT; 
.................... struct BnDLC_transmit B1DLCT; 
.................... struct BnDLC_transmit B2DLCT; 
.................... struct BnDLC_transmit B3DLCT; 
.................... struct BnDLC_transmit B4DLCT; 
.................... struct BnDLC_transmit B5DLCT; 
.................... #byte B0DLCT = getenv("SFR:B0DLC")     //0xE25 
.................... #byte B1DLCT = getenv("SFR:B1DLC")     //0xE35 
.................... #byte B2DLCT = getenv("SFR:B2DLC")     //0xE45 
.................... #byte B3DLCT = getenv("SFR:B3DLC")     //0xE55 
.................... #byte B4DLCT = getenv("SFR:B4DLC")     //0xE65 
.................... #byte B5DLCT = getenv("SFR:B5DLC")     //0xE75 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////// General Purpose Buffers //////////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #byte B5D7 = getenv("SFR:B5D7")     //0xE7D 
.................... #byte B5D6 = getenv("SFR:B5D6")     //0xE7C 
.................... #byte B5D5 = getenv("SFR:B5D5")     //0xE7B 
.................... #byte B5D4 = getenv("SFR:B5D4")     //0xE7A 
.................... #byte B5D3 = getenv("SFR:B5D3")     //0xE79 
.................... #byte B5D2 = getenv("SFR:B5D2")     //0xE78 
.................... #byte B5D1 = getenv("SFR:B5D1")     //0xE77 
.................... #byte B5D0 = getenv("SFR:B5D0")     //0xE76 
....................  
.................... #byte B4D7 = getenv("SFR:B4D7")     //0xE6D 
.................... #byte B4D6 = getenv("SFR:B4D6")     //0xE6C 
.................... #byte B4D5 = getenv("SFR:B4D5")     //0xE6B 
.................... #byte B4D4 = getenv("SFR:B4D4")     //0xE6A 
.................... #byte B4D3 = getenv("SFR:B4D3")     //0xE69 
.................... #byte B4D2 = getenv("SFR:B4D2")     //0xE68 
.................... #byte B4D1 = getenv("SFR:B4D1")     //0xE67 
.................... #byte B4D0 = getenv("SFR:B4D0")     //0xE66 
....................  
.................... #byte B3D7 = getenv("SFR:B3D7")     //0xE5D 
.................... #byte B3D6 = getenv("SFR:B3D6")     //0xE5C 
.................... #byte B3D5 = getenv("SFR:B3D5")     //0xE5B 
.................... #byte B3D4 = getenv("SFR:B3D4")     //0xE5A 
.................... #byte B3D3 = getenv("SFR:B3D3")     //0xE59 
.................... #byte B3D2 = getenv("SFR:B3D2")     //0xE58 
.................... #byte B3D1 = getenv("SFR:B3D1")     //0xE57 
.................... #byte B3D0 = getenv("SFR:B3D0")     //0xE56 
....................  
.................... #byte B2D7 = getenv("SFR:B2D7")     //0xE4D 
.................... #byte B2D6 = getenv("SFR:B2D6")     //0xE4C 
.................... #byte B2D5 = getenv("SFR:B2D5")     //0xE4B 
.................... #byte B2D4 = getenv("SFR:B2D4")     //0xE4A 
.................... #byte B2D3 = getenv("SFR:B2D3")     //0xE49 
.................... #byte B2D2 = getenv("SFR:B2D2")     //0xE48 
.................... #byte B2D1 = getenv("SFR:B2D1")     //0xE47 
.................... #byte B2D0 = getenv("SFR:B2D0")     //0xE46 
....................  
.................... #byte B1D7 = getenv("SFR:B1D7")     //0xE3D 
.................... #byte B1D6 = getenv("SFR:B1D6")     //0xE3C 
.................... #byte B1D5 = getenv("SFR:B1D5")     //0xE3B 
.................... #byte B1D4 = getenv("SFR:B1D4")     //0xE3A 
.................... #byte B1D3 = getenv("SFR:B1D3")     //0xE39 
.................... #byte B1D2 = getenv("SFR:B1D2")     //0xE38 
.................... #byte B1D1 = getenv("SFR:B1D1")     //0xE37 
.................... #byte B1D0 = getenv("SFR:B1D0")     //0xE36 
....................  
.................... #byte B0D7 = getenv("SFR:B0D7")     //0xE2D 
.................... #byte B0D6 = getenv("SFR:B0D6")     //0xE2C 
.................... #byte B0D5 = getenv("SFR:B0D5")     //0xE2B 
.................... #byte B0D4 = getenv("SFR:B0D4")     //0xE2A 
.................... #byte B0D3 = getenv("SFR:B0D3")     //0xE29 
.................... #byte B0D2 = getenv("SFR:B0D2")     //0xE28 
.................... #byte B0D1 = getenv("SFR:B0D1")     //0xE27 
.................... #byte B0D0 = getenv("SFR:B0D0")     //0xE26 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////// General Purpose Buffer ID Registers /////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // standard Identifier bytes 
.................... #byte B0SIDH = getenv("SFR:B0SIDH")    //0xE21 
.................... #byte B1SIDH = getenv("SFR:B1SIDH")    //0xE31 
.................... #byte B2SIDH = getenv("SFR:B2SIDH")    //0xE41 
.................... #byte B3SIDH = getenv("SFR:B3SIDH")    //0xE51 
.................... #byte B4SIDH = getenv("SFR:B4SIDH")    //0xE61 
.................... #byte B5SIDH = getenv("SFR:B5SIDH")    //0xE71 
....................  
.................... #byte B0SIDL = getenv("SFR:B0SIDL")    //0xE22 
.................... #byte B1SIDL = getenv("SFR:B1SIDL")    //0xE32 
.................... #byte B2SIDL = getenv("SFR:B2SIDL")    //0xE42 
.................... #byte B3SIDL = getenv("SFR:B3SIDL")    //0xE52 
.................... #byte B4SIDL = getenv("SFR:B4SIDL")    //0xE62 
.................... #byte B5SIDL = getenv("SFR:B5SIDL")    //0xE72 
....................  
.................... // extended identifier bytes 
.................... #byte B0EIDH = getenv("SFR:B0EIDH")    //0xE23 
.................... #byte B1EIDH = getenv("SFR:B1EIDH")    //0xE33 
.................... #byte B2EIDH = getenv("SFR:B2EIDH")    //0xE43 
.................... #byte B3EIDH = getenv("SFR:B3EIDH")    //0xE53 
.................... #byte B4EIDH = getenv("SFR:B4EIDH")    //0xE63 
.................... #byte B5EIDH = getenv("SFR:B5EIDH")    //0xE73 
....................  
.................... #byte B0EIDL = getenv("SFR:B0EIDL")    //0xE24 
.................... #byte B1EIDL = getenv("SFR:B1EIDL")    //0xE34 
.................... #byte B2EIDL = getenv("SFR:B2EIDL")    //0xE44 
.................... #byte B3EIDL = getenv("SFR:B3EIDL")    //0xE54 
.................... #byte B4EIDL = getenv("SFR:B4EIDL")    //0xE64 
.................... #byte B5EIDL = getenv("SFR:B5EIDL")    //0xE74 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... ///////////////////////////// Mask Select Registers //////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_MASK_FILTER_ASSOCIATE{ACCEPTANCE_MASK_0=0x00,ACCEPTANCE_MASK_1=0x01, 
....................                                FILTER_15=0x02,NO_MASK=0x03}; 
....................  
.................... //msel0 
.................... struct { 
....................    int fil0:2;   //0:1 filter zero select bits 
....................    int fil1:2;   //2:3 filter one select bits 
....................    int fil2:2;   //4:5 filter two select bits 
....................    int fil3:2;   //6:7 filter three select bits 
.................... } MSEL0; 
....................  
.................... //msel1 
.................... struct { 
....................    int fil4:2;   //0:1 filter four select bits 
....................    int fil5:2;   //2:3 filter five select bits 
....................    int fil6:2;   //4:5 filter six select bits 
....................    int fil7:2;   //6:7 filter seven select bits 
.................... } MSEL1; 
....................  
.................... //msel2 
.................... struct { 
....................    int fil8:2;   //0:1 filter eight select bits 
....................    int fil9:2;   //2:3 filter nine select bits 
....................    int fil10:2;  //4:5 filter ten select bits 
....................    int fil11:2;  //6:7 filter eleven select bits 
.................... } MSEL2; 
....................  
.................... //msel3 
.................... struct { 
....................    int fil12:2;   //0:1 filter twelve select bits 
....................    int fil13:2;   //2:3 filter thirteen select bits 
....................    int fil14:2;   //4:5 filter fourteen select bits 
....................    int fil15:2;   //6:7 filter fifteen select bits 
.................... } MSEL3; 
....................  
.................... #byte MSEL0 = getenv("SFR:MSEL0")      //0xDF0 
.................... #byte MSEL1 = getenv("SFR:MSEL1")      //0xDF1 
.................... #byte MSEL2 = getenv("SFR:MSEL2")      //0xDF2 
.................... #byte MSEL3 = getenv("SFR:MSEL3")      //0xDF3 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /////////////////// Transmit interrupts enable register //////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //txbie 
.................... struct { 
....................    int  void01:2; //0:1 
....................    int1 txb0ie;   //2  transmit buffer 0 interrupt enable bit 
....................    int1 txb1ie;   //3  transmit buffer 1 interrupt enable bit 
....................    int1 txb2ie;   //4  transmit buffer 2 interrupt enable bit 
....................    int  void567;  //5:7 
.................... } txbie; 
....................  
.................... #byte txbie = getenv("SFR:TXBIE")      //0xDFC 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //////////////////// Buffer interrupt enable register ////////////////////////// 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... //bie0 
.................... struct { 
....................    int1 rxb0ie;    //0 dedicated receive buffer 0 interrupt enable bit 
....................    int1 rxb1ie;    //1 dedicated receive buffer 1 interrupt enable bit 
....................    int1 b0ie;      //2 programmable transmit/receive buffer 0 interrupt enable bit 
....................    int1 b1ie;      //3 programmable transmit/receive buffer 1 interrupt enable bit 
....................    int1 b2ie;      //4 programmable transmit/receive buffer 2 interrupt enable bit 
....................    int1 b3ie;      //5 programmable transmit/receive buffer 3 interrupt enable bit 
....................    int1 b4ie;      //6 programmable transmit/receive buffer 4 interrupt enable bit 
....................    int1 b5ie;      //7 programmable transmit/receive buffer 5 interrupt enable bit 
.................... } bie0; 
....................  
.................... #byte bie0 = getenv("SFR:BIE0")     //0xDFA 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... enum CAN_FILTER_CONTROL{RXF0EN=0x0001, RXF1EN=0x0002, RXF2EN=0x0004, RXF3EN=0x0008, 
....................                         RXF4EN=0x0010, RXF5EN=0x0020, RXF6EN=0x0040, RXF7EN=0x0080, 
....................                         RXF8EN=0x0100, RXF9EN=0x0200,RXF10EN=0x0400,RXF11EN=0x0800, 
....................                        RXF12EN=0x1000,RXF13EN=0x2000,RXF14EN=0x4000,RXF15EN=0x8000}; 
....................  
.................... //receive filter control registers 
.................... #byte RXFCON0 = getenv("SFR:RXFCON0")     //0xDD4 
.................... #byte RXFCON1 = getenv("SFR:RXFCON1")     //0xDD5 
....................  
.................... //standard data bytes filter length count register 
.................... #byte SDFLC = getenv("SFR:SDFLC")      //0xDD8 
....................  
.................... // enumerated buffers and filters 
.................... enum CAN_FILTER_ASSOCIATION{F0BP=0x00 ,F1BP=0x01 ,F2BP=0x02 ,F3BP=0x03 ,F4BP=0x04, 
....................                             F5BP=0x05 ,F6BP=0x06 ,F7BP=0x07 ,F8BP=0x08 ,F9BP=0x09, 
....................                               F10BP=0x0A,F11BP=0x0B,F12BP=0x0C,F13BP=0x0D,F14BP=0x0E, 
....................                             F15BP=0x0F}; 
....................  
.................... enum CAN_FILTER_ASSOCIATION_BUFFERS { ARXB0=0x00, ARXB1=0x01, AB0=0x02, AB1=0x03, AB2=0x04, AB3=0x05, 
....................                AB4=0x06, AB5=0x07 }; 
....................  
.................... //receive filter buffer control registers 
.................... #byte RXFBCON0 = getenv("SFR:RXFBCON0")      //0xDE0 
.................... #byte RXFBCON1 = getenv("SFR:RXFBCON1")      //0xDE1 
.................... #byte RXFBCON2 = getenv("SFR:RXFBCON2")      //0xDE2 
.................... #byte RXFBCON3 = getenv("SFR:RXFBCON3")      //0xDE3 
.................... #byte RXFBCON4 = getenv("SFR:RXFBCON4")      //0xDE4 
.................... #byte RXFBCON5 = getenv("SFR:RXFBCON5")      //0xDE5 
.................... #byte RXFBCON6 = getenv("SFR:RXFBCON6")      //0xDE6 
.................... #byte RXFBCON7 = getenv("SFR:RXFBCON7")      //0xDE7 
....................  
.................... //receive buffer n standard identifier 
.................... #byte   RXB0SIDH = getenv("SFR:RXB0SIDH")    //0xF61 
.................... #byte   RXB0SIDL = getenv("SFR:RXB0SIDL")    //0xF62 
.................... #byte   RXB1SIDH = getenv("SFR:RXB1SIDH")    //0xF51 
.................... #byte   RXB1SIDL = getenv("SFR:RXB1SIDL")    //0xF52 
....................  
.................... //receive buffer n extended identifier 
.................... #byte   RXB0EIDH = getenv("SFR:RXB0EIDH")    //0xF63 
.................... #byte   RXB0EIDL = getenv("SFR:RXB0EIDL")    //0xF64 
.................... #byte   RXB1EIDH = getenv("SFR:RXB1EIDH")    //0xF53 
.................... #byte   RXB1EIDL = getenv("SFR:RXB1EIDL")    //0xF54 
....................  
.................... #byte TXRXBaEIDL = 0xF64 
....................  
.................... struct { 
....................    int void012:3; //0:3 
....................    int1 ext;      //extendid id 
....................    int1 srr;      //substitute remove request bit 
....................    int void567:3; //5:7 
.................... } TXRXBaSIDL; 
.................... #byte TXRXBaSIDL = 0xF62 
....................  
.................... //receive buffer n data length code register 
.................... struct rxbNdlc_struct { 
....................    int dlc:4;   //0:3 //data length code 
....................    int1 rb0;    //4   //reserved 
....................    int1 rb1;    //5   //reserved 
....................    int1 rtr;    //6   //receiver remote transmission request bit 
....................    int1 void7;  //7 
.................... }; 
.................... struct rxbNdlc_struct RXB0DLC; 
.................... struct rxbNdlc_struct RXB1DLC; 
.................... struct rxbNdlc_struct RXBaDLC; 
.................... #byte   RXB0DLC = getenv("SFR:RXB0DLC")      //0xF65 
.................... #byte   RXB1DLC = getenv("SFR:RXB1DLC")      //0xF55 
.................... #byte   RXBaDLC = getenv("SFR:RXB0DLC")      //0xF65 
....................  
.................... //receive buffer n data field byte m register 
.................... #byte RXB0D0 = getenv("SFR:RXB0D0")    //0xF66 
.................... #byte RXB0D7 = getenv("SFR:RXB0D7")    //0xF6D 
.................... #byte TXRXBaD0 = 0xF66 
.................... #byte TXRXBaD7 = 0xF6D 
....................  
.................... //receive error count 
.................... #byte RXERRCNT = getenv("SFR:RXERRCNT")      //0xF75 
....................  
.................... //receive acceptance filter n standard identifier 
.................... #byte RXF0SIDH = getenv("SFR:RXF0SIDH")      //0xF00 
.................... #byte RXF0SIDL = getenv("SFR:RXF0SIDL")      //0xF01 
.................... #byte RXF1SIDH = getenv("SFR:RXF1SIDH")      //0xF04 
.................... #byte RXF1SIDL = getenv("SFR:RXF1SIDL")      //0xF05 
.................... #byte RXF2SIDH = getenv("SFR:RXF2SIDH")      //0xF08 
.................... #byte RXF2SIDL = getenv("SFR:RXF2SIDL")      //0xF09 
.................... #byte RXF3SIDH = getenv("SFR:RXF3SIDH")      //0xF0C 
.................... #byte RXF3SIDL = getenv("SFR:RXF3SIDL")      //0xF0D 
.................... #byte RXF4SIDH = getenv("SFR:RXF4SIDH")      //0xF10 
.................... #byte RXF4SIDL = getenv("SFR:RXF4SIDL")      //0xF11 
.................... #byte RXF5SIDH = getenv("SFR:RXF5SIDH")      //0xF14 
.................... #byte RXF5SIDL = getenv("SFR:RXF5SIDL")      //0xF15 
....................  
.................... #byte RXF6SIDH = getenv("SFR:RXF6SIDH")      //0xD60 
.................... #byte RXF6SIDL = getenv("SFR:RXF6SIDL")      //0xD61 
.................... #byte RXF7SIDH = getenv("SFR:RXF7SIDH")      //0xD64 
.................... #byte RXF7SIDL = getenv("SFR:RXF7SIDL")      //0xD65 
.................... #byte RXF8SIDH = getenv("SFR:RXF8SIDH")      //0xD68 
.................... #byte RXF8SIDL = getenv("SFR:RXF8SIDL")      //0xD69 
.................... #byte RXF9SIDH = getenv("SFR:RXF9SIDH")      //0xD70 
.................... #byte RXF9SIDL = getenv("SFR:RXF9SIDL")      //0xD71 
.................... #byte RXF10SIDH = getenv("SFR:RXF10SIDH")    //0xD74 
.................... #byte RXF10SIDL = getenv("SFR:RXF10SIDL")    //0xD75 
.................... #byte RXF11SIDH = getenv("SFR:RXF11SIDH")    //0xD78 
.................... #byte RXF11SIDL = getenv("SFR:RXF11SIDL")    //0xD79 
.................... #byte RXF12SIDH = getenv("SFR:RXF12SIDH")    //0xD80 
.................... #byte RXF12SIDL = getenv("SFR:RXF12SIDL")    //0xD81 
.................... #byte RXF13SIDH = getenv("SFR:RXF13SIDH")    //0xD84 
.................... #byte RXF13SIDL = getenv("SFR:RXF13SIDL")    //0xD85 
.................... #byte RXF14SIDH = getenv("SFR:RXF14SIDH")    //0xD88 
.................... #byte RXF14SIDL = getenv("SFR:RXF14SIDL")    //0xD89 
.................... #byte RXF15SIDH = getenv("SFR:RXF15SIDH")    //0xD90 
.................... #byte RXF15SIDL = getenv("SFR:RXF15SIDL")    //0xD91 
....................  
.................... //receive acceptance filter n extended identifier 
.................... #byte RXF0EIDH = getenv("SFR:RXF0EIDH")      //0xF02 
.................... #byte RXF0EIDL = getenv("SFR:RXF0EIDL")      //0xF03 
.................... #byte RXF1EIDH = getenv("SFR:RXF1EIDH")      //0xF06 
.................... #byte RXF1EIDL = getenv("SFR:RXF1EIDL")      //0xF07 
.................... #byte RXF2EIDH = getenv("SFR:RXF2EIDH")      //0xF0A 
.................... #byte RXF2EIDL = getenv("SFR:RXF2EIDL")      //0xF0B 
.................... #byte RXF3EIDH = getenv("SFR:RXF3EIDH")      //0xF0E 
.................... #byte RXF3EIDL = getenv("SFR:RXF3EIDL")      //0xF0F 
.................... #byte RXF4EIDH = getenv("SFR:RXF4EIDH")      //0xF12 
.................... #byte RXF4EIDL = getenv("SFR:RXF4EIDL")      //0xF13 
.................... #byte RXF5EIDH = getenv("SFR:RXF5EIDH")      //0xF16 
.................... #byte RXF5EIDL = getenv("SFR:RXF5EIDL")      //0xF17 
....................  
.................... #byte RXF6EIDH = getenv("SFR:RXF6EIDH")      //0xD62 
.................... #byte RXF6EIDL = getenv("SFR:RXF6EIDL")      //0xD63 
.................... #byte RXF7EIDH = getenv("SFR:RXF7EIDH")      //0xD66 
.................... #byte RXF7EIDL = getenv("SFR:RXF7EIDL")      //0xD67 
.................... #byte RXF8EIDH = getenv("SFR:RXF8EIDH")      //0xD6A 
.................... #byte RXF8EIDL = getenv("SFR:RXF8EIDL")      //0xD6B 
.................... #byte RXF9EIDH = getenv("SFR:RXF9EIDH")      //0xD72 
.................... #byte RXF9EIDL = getenv("SFR:RXF9EIDL")      //0xD73 
.................... #byte RXF10EIDH = getenv("SFR:RXF10EIDH")    //0xD76 
.................... #byte RXF10EIDL = getenv("SFR:RXF10EIDL")    //0xD77 
.................... #byte RXF11EIDH = getenv("SFR:RXF11EIDH")    //0xD7A 
.................... #byte RXF11EIDL = getenv("SFR:RXF11EIDL")    //0xD7B 
.................... #byte RXF12EIDH = getenv("SFR:RXF12EIDH")    //0xD82 
.................... #byte RXF12EIDL = getenv("SFR:RXF12EIDL")    //0xD83 
.................... #byte RXF13EIDH = getenv("SFR:RXF13EIDH")    //0xD86 
.................... #byte RXF13EIDL = getenv("SFR:RXF13EIDL")    //0xD87 
.................... #byte RXF14EIDH = getenv("SFR:RXF14EIDH")    //0xD8A 
.................... #byte RXF14EIDL = getenv("SFR:RXF14EIDL")    //0xD8B 
.................... #byte RXF15EIDH = getenv("SFR:RXF15EIDH")    //0xD92 
.................... #byte RXF15EIDL = getenv("SFR:RXF15EIDL")    //0xD93 
....................  
.................... // simple filter names 
.................... #define RXFILTER0 getenv("SFR:RXF0EIDL")     //0xF03 
.................... #define RXFILTER1 getenv("SFR:RXF1EIDL")     //0xF07 
.................... #define RXFILTER2 getenv("SFR:RXF2EIDL")     //0xF0B 
.................... #define RXFILTER3 getenv("SFR:RXF3EIDL")     //0xF0F 
.................... #define RXFILTER4 getenv("SFR:RXF4EIDL")     //0xF13 
.................... #define RXFILTER5 getenv("SFR:RXF5EIDL")     //0xF17 
.................... #define RXFILTER6 getenv("SFR:RXF6EIDL")     //0xD63 
.................... #define RXFILTER7 getenv("SFR:RXF7EIDL")     //0xD67 
.................... #define RXFILTER8 getenv("SFR:RXF8EIDL")     //0xD6B 
.................... #define RXFILTER9 getenv("SFR:RXF9EIDL")     //0xD73 
.................... #define RXFILTER10 getenv("SFR:RXF10EIDL")   //0xD77 
.................... #define RXFILTER11 getenv("SFR:RXF11EIDL")   //0xD7B 
.................... #define RXFILTER12 getenv("SFR:RXF12EIDL")   //0xD83 
.................... #define RXFILTER13 getenv("SFR:RXF13EIDL")   //0xD87 
.................... #define RXFILTER14 getenv("SFR:RXF14EIDL")   //0xD8B 
.................... #define RXFILTER15 getenv("SFR:RXF15EIDL")   //0xD93 
....................  
.................... //receive acceptance mask n standard identifier mask 
.................... #byte RXM0SIDH = getenv("SFR:RXM0SIDH")      //0xF18 
.................... #byte RXM0SIDL = getenv("SFR:RXM0SIDL")      //0xF19 
.................... #byte RXM1SIDH = getenv("SFR:RXM1SIDH")      //0xF1C 
.................... #byte RXM1SIDL = getenv("SFR:RXM1SIDL")      //0xF1D 
....................  
.................... //receive acceptance mask n extended identifier mask 
.................... #byte RXM0EIDH = getenv("SFR:RXM0EIDH")      //0xF1A 
.................... #byte RXM0EIDL = getenv("SFR:RXM0EIDL")      //0xF1B 
.................... #byte RXM1EIDH = getenv("SFR:RXM1EIDH")      //0xF1E 
.................... #byte RXM1EIDL = getenv("SFR:RXM1EIDL")      //0xF1F 
....................  
.................... //value to put in mask field to accept all incoming id's 
.................... #define CAN_MASK_ACCEPT_ALL   0 
....................  
.................... //can interrupt flags 
.................... #bit CAN_INT_IRXIF = getenv("BIT:IRXIF")     //0xFA4.7 
.................... #bit CAN_INT_WAKIF = getenv("BIT:WAKIF")     //0xFA4.6 
.................... #bit CAN_INT_ERRIF = getenv("BIT:ERRIF")     //0xFA4.5 
.................... #bit CAN_INT_TXB2IF = getenv("BIT:TXB2IF")   //0xFA4.4 
.................... #bit CAN_INT_TXB1IF = getenv("BIT:TXB1IF")   //0xFA4.3 
.................... #bit CAN_INT_TXB0IF = getenv("BIT:TXB0IF")   //0xFA4.2 
.................... #bit CAN_INT_RXB1IF = getenv("BIT:RXB1IF")   //0xFA4.1 
.................... #bit CAN_INT_RXB0IF = getenv("BIT:RXB0IF")   //0xFA4.0 
....................  
.................... //PROTOTYPES 
....................  
.................... struct rx_stat { 
....................    int1 err_ovfl;          // buffer overflow 
....................    unsigned int filthit;   // filter that allowed the frame into the buffer 
....................    unsigned int  buffer;   // receive buffer 
....................    int1 rtr;               // rtr requested 
....................    int1 ext;               // extended id 
....................    int1 inv;               // invalid id? 
.................... }; 
....................  
.................... void  can_init(void); 
.................... void  can_set_baud(void); 
.................... void  can_set_mode(CAN_OP_MODE mode); 
.................... void  can_set_functional_mode(CAN_FUN_OP_MODE mode); 
.................... void  can_set_id(unsigned int *addr, unsigned int32 id, int1 ext); 
.................... unsigned int32 can_get_id(unsigned int *addr, int1 ext); 
.................... int1  can_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int priority, int1 ext, int1 rtr); 
.................... int1  can_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat); 
.................... void  can_enable_rtr(PROG_BUFFER b); 
.................... void  can_disable_rtr(PROG_BUFFER b); 
.................... void  can_load_rtr(PROG_BUFFER b, unsigned int *data, unsigned int len); 
.................... void can_enable_filter(unsigned long filter); 
.................... void can_disable_filter(unsigned long filter); 
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter); 
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATE mask, CAN_FILTER_ASSOCIATION filter); 
.................... int1 can_fifo_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat); 
....................  
.................... #endif 
....................  
....................  
.................... #if CAN_DO_DEBUG 
....................  #use rs232(baud=9600, xmit=PIN_C6, rcv=PIN_C7) 
....................  #define can_debug printf 
.................... #else 
....................  #define can_debug 
.................... #endif 
....................  
.................... //macros 
.................... #define can_kbhit() (RXB0CON.rxful || RXB1CON.rxful || (B0CONR.rxful && !BSEL0.b0txen) || (B1CONR.rxful && !BSEL0.b1txen) || (B2CONR.rxful && !BSEL0.b2txen) || (B3CONR.rxful && !BSEL0.b3txen) || (B4CONR.rxful && !BSEL0.b4txen) || (B5CONR.rxful && !BSEL0.b5txen)) 
.................... #define can_tbe() (!TXB0CON.txreq || !TXB1CON.txreq || !TXB2CON.txreq || (!B0CONT.txreq && BSEL0.b0txen) || (!B1CONT.txreq && BSEL0.b1txen) || (!B2CONT.txreq && BSEL0.b2txen) || (!B3CONT.txreq && BSEL0.b3txen) || (!B4CONT.txreq && BSEL0.b4txen) || (!B5CONT.txreq && BSEL0.b5txen)) 
.................... #define can_abort()                 (CANCON.abat=1) 
....................  
.................... // current mode variable 
.................... // used by many of the device drivers to prevent damage from the mode 
.................... // 
.................... unsigned int curmode; 
.................... unsigned int curfunmode; 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_init() 
.................... // 
.................... // Initializes PIC18xxx8 CAN peripheral.  Sets the RX filter and masks so the 
.................... // CAN peripheral will receive all incoming IDs.  Configures both RX buffers 
.................... // to only accept valid messages (as opposed to all messages, or all 
.................... // extended message, or all standard messages).  Also sets the tri-state 
.................... // setting of B2 to output, and B3 to input (apparently the CAN peripheral 
.................... // doesn't keep track of this) 
.................... // 
.................... // The constants (CAN_USE_RX_DOUBLE_BUFFER, CAN_ENABLE_DRIVE_HIGH, 
.................... // CAN_ENABLE_CAN_CAPTURE) are given a default define in the can-18xxx8.h file. 
.................... // These default values can be overwritten in the main code, but most 
.................... // applications will be fine with these defaults. 
.................... // 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... void can_init(void) { 
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
*
0180:  MOVLW  04
0182:  MOVWF  0C
0184:  RCALL  0004
....................    can_set_baud(); 
0186:  BRA    0026
....................    curfunmode=CAN_FUN_OP_LEGACY; 
0188:  CLRF   05
....................  
....................    // RXB0CON 
....................    //    filthit0=0 
....................    //    jtoff=0 
....................    //      rxb0dben=1   buffer zero will overflow into buffer one 
....................    //      rxrtrro=0 
....................    //      rxm1:0=0      will receive all valid IDs 
....................    RXB0CON=0; 
018A:  CLRF   F60
....................    RXB0CON.rxm=CAN_RX_VALID; 
018C:  MOVLW  9F
018E:  ANDWF  F60,W
0190:  MOVWF  F60
....................    RXB0CON.rxb0dben=CAN_USE_RX_DOUBLE_BUFFER; 
0192:  BSF    F60.2
....................    RXB1CON=RXB0CON; 
0194:  MOVFF  F60,F30
....................  
....................    CIOCON.endrhi=CAN_ENABLE_DRIVE_HIGH; 
0198:  BCF    F70.5
....................    CIOCON.cancap=CAN_ENABLE_CAN_CAPTURE; 
019A:  BCF    F70.4
....................    CIOCON.tx2src=CAN_CANTX2_SOURCE;       //added for PIC18F6585/8585/6680/8680 
019C:  BCF    F70.7
....................    CIOCON.tx2en=CAN_ENABLE_CANTX2;        //added for PIC18F6585/8585/6680/8680 
019E:  BCF    F70.6
....................  
....................    can_set_id(RX0MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 0 
01A0:  MOVLW  0E
01A2:  MOVWF  1B
01A4:  MOVLW  FB
01A6:  MOVWF  1A
01A8:  CLRF   1F
01AA:  CLRF   1E
01AC:  CLRF   1D
01AE:  CLRF   1C
01B0:  CLRF   20
01B2:  RCALL  0058
....................    can_set_id(RXFILTER0, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 0 
01B4:  MOVLW  0E
01B6:  MOVWF  1B
01B8:  MOVLW  E3
01BA:  MOVWF  1A
01BC:  CLRF   1F
01BE:  CLRF   1E
01C0:  CLRF   1D
01C2:  CLRF   1C
01C4:  CLRF   20
01C6:  RCALL  0058
....................    can_set_id(RXFILTER1, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 0 
01C8:  MOVLW  0E
01CA:  MOVWF  1B
01CC:  MOVLW  E7
01CE:  MOVWF  1A
01D0:  CLRF   1F
01D2:  CLRF   1E
01D4:  CLRF   1D
01D6:  CLRF   1C
01D8:  CLRF   20
01DA:  RCALL  0058
....................  
....................    can_set_id(RX1MASK, CAN_MASK_ACCEPT_ALL, CAN_USE_EXTENDED_ID);  //set mask 1 
01DC:  MOVLW  0E
01DE:  MOVWF  1B
01E0:  SETF   1A
01E2:  CLRF   1F
01E4:  CLRF   1E
01E6:  CLRF   1D
01E8:  CLRF   1C
01EA:  CLRF   20
01EC:  RCALL  0058
....................    can_set_id(RXFILTER2, 0, CAN_USE_EXTENDED_ID);  //set filter 0 of mask 1 
01EE:  MOVLW  0E
01F0:  MOVWF  1B
01F2:  MOVLW  EB
01F4:  MOVWF  1A
01F6:  CLRF   1F
01F8:  CLRF   1E
01FA:  CLRF   1D
01FC:  CLRF   1C
01FE:  CLRF   20
0200:  RCALL  0058
....................    can_set_id(RXFILTER3, 0, CAN_USE_EXTENDED_ID);  //set filter 1 of mask 1 
0202:  MOVLW  0E
0204:  MOVWF  1B
0206:  MOVLW  EF
0208:  MOVWF  1A
020A:  CLRF   1F
020C:  CLRF   1E
020E:  CLRF   1D
0210:  CLRF   1C
0212:  CLRF   20
0214:  RCALL  0058
....................    can_set_id(RXFILTER4, 0, CAN_USE_EXTENDED_ID);  //set filter 2 of mask 1 
0216:  MOVLW  0E
0218:  MOVWF  1B
021A:  MOVLW  F3
021C:  MOVWF  1A
021E:  CLRF   1F
0220:  CLRF   1E
0222:  CLRF   1D
0224:  CLRF   1C
0226:  CLRF   20
0228:  RCALL  0058
....................    can_set_id(RXFILTER5, 0, CAN_USE_EXTENDED_ID);  //set filter 3 of mask 1 
022A:  MOVLW  0E
022C:  MOVWF  1B
022E:  MOVLW  F7
0230:  MOVWF  1A
0232:  CLRF   1F
0234:  CLRF   1E
0236:  CLRF   1D
0238:  CLRF   1C
023A:  CLRF   20
023C:  RCALL  0058
....................  
....................    // set dynamic filters 
....................    can_set_id(RXFILTER6, 0, CAN_USE_EXTENDED_ID); 
023E:  MOVLW  0E
0240:  MOVWF  1B
0242:  MOVLW  4B
0244:  MOVWF  1A
0246:  CLRF   1F
0248:  CLRF   1E
024A:  CLRF   1D
024C:  CLRF   1C
024E:  CLRF   20
0250:  RCALL  0058
....................    can_set_id(RXFILTER7, 0, CAN_USE_EXTENDED_ID); 
0252:  MOVLW  0E
0254:  MOVWF  1B
0256:  MOVLW  4F
0258:  MOVWF  1A
025A:  CLRF   1F
025C:  CLRF   1E
025E:  CLRF   1D
0260:  CLRF   1C
0262:  CLRF   20
0264:  RCALL  0058
....................    can_set_id(RXFILTER8, 0, CAN_USE_EXTENDED_ID); 
0266:  MOVLW  0E
0268:  MOVWF  1B
026A:  MOVLW  53
026C:  MOVWF  1A
026E:  CLRF   1F
0270:  CLRF   1E
0272:  CLRF   1D
0274:  CLRF   1C
0276:  CLRF   20
0278:  RCALL  0058
....................    can_set_id(RXFILTER9, 0, CAN_USE_EXTENDED_ID); 
027A:  MOVLW  0E
027C:  MOVWF  1B
027E:  MOVLW  57
0280:  MOVWF  1A
0282:  CLRF   1F
0284:  CLRF   1E
0286:  CLRF   1D
0288:  CLRF   1C
028A:  CLRF   20
028C:  RCALL  0058
....................    can_set_id(RXFILTER10, 0, CAN_USE_EXTENDED_ID); 
028E:  MOVLW  0E
0290:  MOVWF  1B
0292:  MOVLW  5B
0294:  MOVWF  1A
0296:  CLRF   1F
0298:  CLRF   1E
029A:  CLRF   1D
029C:  CLRF   1C
029E:  CLRF   20
02A0:  RCALL  0058
....................    can_set_id(RXFILTER11, 0, CAN_USE_EXTENDED_ID); 
02A2:  MOVLW  0E
02A4:  MOVWF  1B
02A6:  MOVLW  5F
02A8:  MOVWF  1A
02AA:  CLRF   1F
02AC:  CLRF   1E
02AE:  CLRF   1D
02B0:  CLRF   1C
02B2:  CLRF   20
02B4:  RCALL  0058
....................    can_set_id(RXFILTER12, 0, CAN_USE_EXTENDED_ID); 
02B6:  MOVLW  0E
02B8:  MOVWF  1B
02BA:  MOVLW  63
02BC:  MOVWF  1A
02BE:  CLRF   1F
02C0:  CLRF   1E
02C2:  CLRF   1D
02C4:  CLRF   1C
02C6:  CLRF   20
02C8:  RCALL  0058
....................    can_set_id(RXFILTER13, 0, CAN_USE_EXTENDED_ID); 
02CA:  MOVLW  0E
02CC:  MOVWF  1B
02CE:  MOVLW  67
02D0:  MOVWF  1A
02D2:  CLRF   1F
02D4:  CLRF   1E
02D6:  CLRF   1D
02D8:  CLRF   1C
02DA:  CLRF   20
02DC:  RCALL  0058
....................    can_set_id(RXFILTER14, 0, CAN_USE_EXTENDED_ID); 
02DE:  MOVLW  0E
02E0:  MOVWF  1B
02E2:  MOVLW  6B
02E4:  MOVWF  1A
02E6:  CLRF   1F
02E8:  CLRF   1E
02EA:  CLRF   1D
02EC:  CLRF   1C
02EE:  CLRF   20
02F0:  RCALL  0058
....................    can_set_id(RXFILTER15, 0, CAN_USE_EXTENDED_ID); 
02F2:  MOVLW  0E
02F4:  MOVWF  1B
02F6:  MOVLW  6F
02F8:  MOVWF  1A
02FA:  CLRF   1F
02FC:  CLRF   1E
02FE:  CLRF   1D
0300:  CLRF   1C
0302:  CLRF   20
0304:  RCALL  0058
....................  
....................   #if (getenv("DEVICE") == "PIC18F6585") || (getenv("DEVICE") == "PIC18LF6585") || \ 
....................       (getenv("DEVICE") == "PIC18F6680") || (getenv("DEVICE") == "PIC18LF6680") || \ 
....................       (getenv("DEVICE") == "PIC18F8585") || (getenv("DEVICE") == "PIC18LF8585") || \ 
....................       (getenv("DEVICE") == "PIC18F8680") || (getenv("DEVICE") == "PIC18LF8680") 
....................    set_tris_g((*getenv("SFR:TRISG") & 0xFE) | 0x04);  //G2 in, G0 out 
....................    if(CAN_ENABLE_CANTX2) 
....................     bit_clear(*getenv("SFR:TRISG"), 1);  //G1 out 
....................   #elif getenv("FUSE_SET:CANE") 
....................    set_tris_e((*getenv("SFR:TRISE") & 0xDF) | 0x10);  //E4 in, E5 out 
....................   #elif getenv("FUSE_SET:CANC") 
....................    set_tris_c((*getenv("SFR:TRISC") & 0xBF) | 0x80);  //C7 in, C6 out 
....................   #else 
....................    set_tris_b((*getenv("SFR:TRISB") & 0xFB) | 0x08);  //B3 in, B2 out 
0306:  MOVF   F93,W
0308:  ANDLW  FB
030A:  IORLW  08
030C:  MOVWF  F93
....................   #endif 
....................  
....................    can_set_mode(CAN_OP_NORMAL); 
030E:  CLRF   0C
0310:  RCALL  0004
0312:  GOTO   04EE (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_baud() 
.................... // 
.................... // Configures the baud rate control registers.  All the defines here 
.................... // are defaulted in the can-18xxx8.h file.  These defaults can, and 
.................... // probably should, be overwritten in the main code. 
.................... // 
.................... // Current defaults are set to work with Microchip's MCP250xxx CAN 
.................... // Developers Kit if this PIC is running at 20Mhz. 
.................... // 
.................... //   BRGCON1 contains the prescaler bits and the Synchronization jump 
.................... //         width time bits. 
.................... // 
.................... //           the prescale values are 
.................... //              111111=(2*64)/clock=Tq 
.................... //              111110=(2*63)/clock=Tq 
.................... //                continued 
.................... //              000001=(2*2)/clock=Tq 
.................... //                000000=(2*1)/clock=Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, the prescale bits are set to 
.................... //           000100=10/clock provided that the user does not define it 
.................... //           differently 
.................... // 
.................... //           The Synchronized Jump Width Bits are 
.................... //              11=4*Tq 
.................... //              10=3*Tq 
.................... //              01=2*Tq 
.................... //            00=1*Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, the SJW bits are set to 0 or 1*Tq 
.................... // 
.................... //   BRGCON2 contains the Phase Segment 2 Time Select bit, the sample bit 
.................... //          the Phase Segment 1 bits, and the Propagation Time Select bits 
.................... // 
.................... //           SEG2PHTS 
.................... //                1=Freely Programmable 
.................... //              0=Maximum of PHEG1 or IPT, which ever is greatest 
.................... // 
.................... //           in the case of can-18xxx8.h, the SEG2PHTS bit is set to 1 for 
.................... //           freely programmable 
.................... // 
.................... //           SAM 
.................... //              1=Three Samples 
.................... //              0=One Sample 
.................... // 
.................... //           in the case of can-18xxx8.h, the SAM bit is set to 0 for 
.................... //           one sample 
.................... // 
.................... //           SEG1PH2:SEG1PH0 
.................... //              Phase Segment 1 = (SEG1PH2:SEG1PH0+1)*Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, the SEG1PH2:SEG1PH0 bits are set to 5 
.................... //         for 6*Tq Phase Segment 1 Time 
.................... // 
.................... //           PRSEG2:PRSEG0 
.................... //              Propagation Time = (PRSEG2:PRSEG0+1)*TQ 
.................... // 
.................... //           in the case of can-18xxx8.h, the PRSEG2:PRSEG0 bits are set to 2 
.................... //           for 3*Tq Propagation Time 
.................... // 
.................... // BRGCON3 contains the WAKFIL bit and the Phase Segment 2 Time Select bits 
.................... // 
.................... //           WAKEFIL 
.................... //            1=CAN bus line filter is used for wake-up 
.................... //              0=CAN bus line filter is not used for wake-up 
.................... // 
.................... //           in the case of can-18xx8.h, the WAKEFIL bit is set to 0 for 
.................... //           CAN bus not used for wake-up 
.................... // 
.................... //           SEG2PH2:SEG2PH0 
.................... //              Phase Segment 2 Time = (SEG2PH2:SEG2PH0+1)*Tq 
.................... // 
.................... //           in the case of can-18xxx8.h, SEG2PH2:SEG3PH0 is set to 5 for 
.................... //         6*Tq Phase Segment 2 Time 
.................... // 
.................... // More information can be found in the PIC18F4580 datasheet section 23.9 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_baud(void) { 
....................    BRGCON1.brp=CAN_BRG_PRESCALAR; 
*
0026:  MOVLW  C0
0028:  MOVLB  E
002A:  ANDWF  x43,W
002C:  IORLW  01
002E:  MOVWF  x43
....................    BRGCON1.sjw=CAN_BRG_SYNCH_JUMP_WIDTH; 
0030:  MOVLW  3F
0032:  ANDWF  x43,W
0034:  MOVWF  x43
....................  
....................    BRGCON2.prseg=CAN_BRG_PROPAGATION_TIME; 
0036:  MOVLW  F8
0038:  ANDWF  x44,W
003A:  IORLW  07
003C:  MOVWF  x44
....................    BRGCON2.seg1ph=CAN_BRG_PHASE_SEGMENT_1; 
003E:  MOVLW  C7
0040:  ANDWF  x44,W
0042:  MOVWF  x44
....................    BRGCON2.sam=CAN_BRG_SAM; 
0044:  BCF    x44.6
....................    BRGCON2.seg2phts=CAN_BRG_SEG_2_PHASE_TS; 
0046:  BSF    x44.7
....................  
....................    BRGCON3.seg2ph=CAN_BRG_PHASE_SEGMENT_2; 
0048:  MOVLW  F8
004A:  ANDWF  x45,W
004C:  IORLW  05
004E:  MOVWF  x45
....................    BRGCON3.wakfil=CAN_BRG_WAKE_FILTER; 
0050:  BSF    x45.6
0052:  MOVLB  0
0054:  GOTO   0188 (RETURN)
.................... } 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_mode 
.................... // 
.................... // This function first sets three most significant bits (reqop2:reqop0) 
.................... // to the mode given through the argument.  The modes can be 
.................... // 
.................... // mode 
.................... // 
.................... // 1xx  -> Configuration Mode 
.................... //             This mode allows the user to configure the Control Registers, 
.................... //            the Acceptance Mask Registers and the Acceptance Filter 
.................... //            Registers. 
.................... // 
.................... // 011  -> Listen Only Mode 
.................... //            This mode allows the PIC microcontroller to listen to the 
.................... //            bus but not actually write to it. 
.................... // 
.................... // 010  -> Loop Back Mode 
.................... //            This mode allows to the transmission of data directly from 
.................... //            the Transmission Buffers to the Receive Buffers without 
.................... //            actually driving any data to the bus 
.................... // 
.................... // 001  -> Disable Mode 
.................... //            This mode prevents the PIC microcontroller from transmitting 
.................... //            and receiving, however the WAKIF interrupt is still active 
.................... // 
.................... // 000  -> Normal Mode 
.................... //            This is the normal mode of operation for the CAN bus.  It 
.................... //            will receive all messages and is the only mode in which 
.................... //            data can be transmitted. 
.................... // 
.................... //   The reqop bits do not immediately change the mode of operation, the 
.................... // three most significant bits in the CANSTAT register (opmode2:opmode0) 
.................... // must change to reflect the actual change in mode, therefore a while 
.................... // statement is used to check if the CANSTAT opmode bits have changed to 
.................... // reflect the passed in mode 
.................... // 
.................... // More information can be found in the PIC18F4580 datasheet section 23.3 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_mode(CAN_OP_MODE mode) { 
....................    CANCON.reqop=mode; 
*
0004:  SWAPF  0C,W
0006:  ANDLW  70
0008:  MOVWF  00
000A:  BCF    FD8.0
000C:  RLCF   00,F
000E:  MOVLW  1F
0010:  ANDWF  F6F,W
0012:  IORWF  00,W
0014:  MOVWF  F6F
....................    while( (CANSTAT.opmode) != mode ); 
0016:  MOVFF  F6E,00
001A:  SWAPF  00,F
001C:  RRCF   00,W
001E:  ANDLW  07
0020:  SUBWF  0C,W
0022:  BNZ   0016
0024:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_functional_mode 
.................... // 
.................... // This function sets the functional mode of the PIC18F4580 ECAN module 
.................... // 
.................... //   mode 
.................... // 
.................... // 00    -> mode 0 or Legacy Mode.  The processor defaults to this mode 
.................... //            on reset in order to maintain backwards compatibility will 
.................... //            the previous PIC18Cxx8 and PIC18Fxx8 CAN modules.  All code 
.................... //            written for the listed microcontrollers will work on the 
.................... //            PIC18F4580 will no alterations. 
.................... // 
.................... //            This mode provides the exact same registers as the previous 
.................... //            modules.  These include 
.................... // 
.................... //            3 Transmit Buffers: TXB0, TXB1, TXB2 
.................... //            2 Receive Buffers: RXB0, RXB1 
.................... //            2 Acceptance Masks: RXM0, RXM1 
.................... //            6 Acceptance Filters: RXF0, RXF1, RXF2, RXF3, RXF4, RXF5 
.................... // 
.................... // 01  -> mode 1 or Enhanced Legacy Mode. This mode is the same as mode 
.................... //            0 with the exception that there are more resources available 
.................... //            to the CAN module.  These include 
.................... // 
.................... //            3  Transmit Buffers: TXB0, TXB1, TXB2 
.................... //            2  Receive Buffers: RXB0, RXB1 
.................... //            6  Programmable Buffers: B0, B1, B2, B3, B4, B5 
.................... //               Automatic RTR Handling on: B0, B1, B2, B3, B4, B5 
.................... //            16 Dynamically assigned acceptance filters: RXF0-RXF15 
.................... //            2  Dedicated mask registers,RXM0: RXM1 
.................... //            1  Programmable mask register: RXF15 
.................... //               Programmable data filter on standard identifier messages: SDFLC 
.................... // 
.................... // 10    -> mode 2 or Enhanced FIFO Mode.  This mode produces a first in 
.................... //            first out (FIFO) CAN data buffer.  This buffer can be from 2 too 
.................... //            8 bytes in length depending on which B buffers are used as receive 
.................... //            buffers and which are used as transmit buffers.  The first transmit 
.................... //            buffer defines the size, therefore if B4 was the first transmit 
.................... //            buffer, RXB0, BXB1, B0, B1, B2, and B3 would form the FIFO buffer 
.................... //            for a size of 6 bytes.  If B0 through B5 are all set to receive data, 
.................... //            the size will be 8 bytes.  If B0 is set to transmit, the size will 
.................... //            be 2 bytes.  The available resources include 
.................... // 
.................... //            3  Transmit Buffers: TXB0, TXB1, TXB2 
.................... //            2  Receive Buffers: RXB0, RXB1 
.................... //            6  Programmable Buffers: B0, B1, B2, B3, B4, B5 
.................... //               Automatic RTR Handling on: B0, B1, B2, B3, B4, B5 
.................... //            16 Acceptance Filters: RXF0-RXF15 
.................... //            2  Dedicated Mask Registers: RXM0, RXM1 
.................... //            1  Programmable mask register: RXF15 
.................... //               Programmable data filter on standard identifier messages: SDFLC 
.................... // 
.................... //   More information can be found in the PIC18F4580 datasheet section 23.4 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_set_functional_mode(CAN_FUN_OP_MODE mode) 
.................... { 
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG);   //must be in config mode before params can be set 
....................    ECANCON.mdsel=mode; 
....................    curfunmode=mode; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_id() 
.................... // 
.................... // Configures the xxxxEIDL, xxxxEIDH, xxxxSIDL and xxxxSIDH registers to 
.................... // configure the defined buffer to use the specified ID 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... // 
.................... //     id - ID to set buffer to 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... void can_set_id(unsigned int *addr, unsigned int32 id, int1 ext) { 
....................    //int *ptr; 
....................  
....................    //ptr=addr; 
....................  
....................    if (ext) {  //extended 
*
0058:  MOVF   20,F
005A:  BZ    0100
....................       //eidl 
....................       *addr=make8(id,0); //0:7 
005C:  MOVFF  1A,FE9
0060:  MOVFF  1B,FEA
0064:  MOVFF  1C,FEF
....................  
....................       //eidh 
....................       addr--; 
0068:  MOVF   1A,W
006A:  BTFSC  FD8.2
006C:  DECF   1B,F
006E:  DECF   1A,F
....................       *addr=make8(id,1); //8:15 
0070:  MOVFF  1A,FE9
0074:  MOVFF  1B,FEA
0078:  MOVFF  1D,FEF
....................  
....................       //sidl 
....................       addr--; 
007C:  MOVF   1A,W
007E:  BTFSC  FD8.2
0080:  DECF   1B,F
0082:  DECF   1A,F
....................       *addr=make8(id,2) & 0x03;   //16:17 
0084:  MOVFF  1A,FE9
0088:  MOVFF  1B,FEA
008C:  MOVF   1E,W
008E:  ANDLW  03
0090:  MOVWF  FEF
....................       *addr|=(make8(id,2) << 3) & 0xE0; //18:20 
0092:  MOVFF  1A,FE9
0096:  MOVFF  1B,FEA
009A:  MOVFF  1E,00
009E:  RLCF   00,F
00A0:  RLCF   00,F
00A2:  RLCF   00,F
00A4:  MOVLW  F8
00A6:  ANDWF  00,F
00A8:  MOVF   00,W
00AA:  ANDLW  E0
00AC:  IORWF  FEF,W
00AE:  MOVWF  FEF
....................       *addr|=0x08; 
00B0:  MOVFF  1A,FE9
00B4:  MOVFF  1B,FEA
00B8:  MOVF   FEF,W
00BA:  IORLW  08
00BC:  MOVWF  FEF
....................  
....................  
....................       //sidh 
....................       addr--; 
00BE:  MOVF   1A,W
00C0:  BTFSC  FD8.2
00C2:  DECF   1B,F
00C4:  DECF   1A,F
....................       *addr=((make8(id,2) >> 5) & 0x07 ); //21:23 
00C6:  MOVFF  1A,FE9
00CA:  MOVFF  1B,FEA
00CE:  MOVFF  1E,00
00D2:  SWAPF  00,F
00D4:  RRCF   00,F
00D6:  MOVLW  07
00D8:  ANDWF  00,F
00DA:  MOVF   00,W
00DC:  ANDLW  07
00DE:  MOVWF  FEF
....................       *addr|=((make8(id,3) << 3) & 0xF8);//24:28 
00E0:  MOVFF  1A,FE9
00E4:  MOVFF  1B,FEA
00E8:  MOVFF  1F,00
00EC:  RLCF   00,F
00EE:  RLCF   00,F
00F0:  RLCF   00,F
00F2:  MOVLW  F8
00F4:  ANDWF  00,F
00F6:  MOVF   00,W
00F8:  ANDLW  F8
00FA:  IORWF  FEF,W
00FC:  MOVWF  FEF
....................    } 
00FE:  BRA    017E
....................    else {   //standard 
....................       //eidl 
....................       *addr=0; 
0100:  MOVFF  1A,FE9
0104:  MOVFF  1B,FEA
0108:  CLRF   FEF
....................  
....................       //eidh 
....................       addr--; 
010A:  MOVF   1A,W
010C:  BTFSC  FD8.2
010E:  DECF   1B,F
0110:  DECF   1A,F
....................       *addr=0; 
0112:  MOVFF  1A,FE9
0116:  MOVFF  1B,FEA
011A:  CLRF   FEF
....................  
....................       //sidl 
....................       addr--; 
011C:  MOVF   1A,W
011E:  BTFSC  FD8.2
0120:  DECF   1B,F
0122:  DECF   1A,F
....................       *addr=(make8(id,0) << 5) & 0xE0; 
0124:  MOVFF  1A,FE9
0128:  MOVFF  1B,FEA
012C:  MOVFF  1C,00
0130:  SWAPF  00,F
0132:  RLCF   00,F
0134:  MOVLW  E0
0136:  ANDWF  00,F
0138:  MOVF   00,W
013A:  ANDLW  E0
013C:  MOVWF  FEF
....................  
....................       //sidh 
....................       addr--; 
013E:  MOVF   1A,W
0140:  BTFSC  FD8.2
0142:  DECF   1B,F
0144:  DECF   1A,F
....................       *addr=(make8(id,0) >> 3) & 0x1F; 
0146:  MOVFF  1A,FE9
014A:  MOVFF  1B,FEA
014E:  MOVFF  1C,00
0152:  RRCF   00,F
0154:  RRCF   00,F
0156:  RRCF   00,F
0158:  MOVLW  1F
015A:  ANDWF  00,F
015C:  MOVF   00,W
015E:  ANDLW  1F
0160:  MOVWF  FEF
....................       *addr|=(make8(id,1) << 5) & 0xE0; 
0162:  MOVFF  1A,FE9
0166:  MOVFF  1B,FEA
016A:  MOVFF  1D,00
016E:  SWAPF  00,F
0170:  RLCF   00,F
0172:  MOVLW  E0
0174:  ANDWF  00,F
0176:  MOVF   00,W
0178:  ANDLW  E0
017A:  IORWF  FEF,W
017C:  MOVWF  FEF
....................    } 
017E:  RETURN 0
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_standard_id 
.................... // 
.................... // sets a standard id 
.................... // 
.................... // Parameters: 
.................... //      addr - the address that is to be set to the id 
.................... //      id - the actual id 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_set_standard_id(unsigned int *addr, unsigned int32 id) 
.................... { 
....................    //eidl 
....................    *addr=0; 
....................  
....................    //eidh 
....................    addr--; 
....................    *addr=0; 
....................  
....................    //sidl 
....................    addr--; 
....................    *addr=(make8(id,0) << 5) & 0xE0; 
....................  
....................    //sidh 
....................    addr--; 
....................    *addr=(make8(id,0) >> 3) & 0x1F; 
....................    *addr|=(make8(id,1) << 5) & 0xE0; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_set_extended_id 
.................... // 
.................... // sets an extended id 
.................... // 
.................... // Parameters: 
.................... //      addr - the address that is to be set to the id 
.................... //      id - the actual id 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_set_extended_id(unsigned int *addr, unsigned int32 id) 
.................... { 
....................    //eidl 
....................    *addr=make8(id,0); //0:7 
....................  
....................    //eidh 
....................    addr--; 
....................    *addr=make8(id,1); //8:15 
....................  
....................    //sidl 
....................    addr--; 
....................    *addr=make8(id,2) & 0x03;   //16:17 
....................    *addr|=(make8(id,2) << 3) & 0xE0; //18:20 
....................    *addr|=0x08; 
....................  
....................  
....................    //sidh 
....................    addr--; 
....................    *addr=((make8(id,2) >> 5) & 0x07 ); //21:23 
....................    *addr|=((make8(id,3) << 3) & 0xF8);//24:28 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_id() 
.................... // 
.................... // Returns the ID of the specified buffer.  (The opposite of can_set_id()) 
.................... // This is used after receiving a message, to see which ID sent the message. 
.................... // 
.................... //   Parameters: 
.................... //     addr - pointer to first byte of ID register, starting with xxxxEIDL. 
.................... //            For example, a pointer to RXM1EIDL 
.................... //     ext - Set to TRUE if this buffer uses an extended ID, FALSE if not 
.................... // 
.................... //   Returns: 
.................... //     The ID of the buffer 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_id(unsigned int *addr, int1 ext) { 
....................    unsigned int32 ret; 
....................    unsigned int *ptr; 
....................  
....................    ret=0; 
....................    ptr=addr; 
....................  
....................    if (ext) { 
....................       ret=*ptr;  //eidl 
....................  
....................       ptr--;     //eidh 
....................       ret|=((unsigned int32)*ptr << 8); 
....................  
....................       ptr--;     //sidl 
....................       ret|=((unsigned int32)*ptr & 0x03) << 16; 
....................       ret|=((unsigned int32)*ptr & 0xE0) << 13; 
....................  
....................       ptr--;     //sidh 
....................       ret|=((unsigned int32)*ptr << 21); 
....................  
....................    } 
....................    else { 
....................       ptr-=2;    //sidl 
....................       ret=((unsigned int32)*ptr & 0xE0) >> 5; 
....................  
....................       ptr--;     //sidh 
....................       ret|=((unsigned int32)*ptr << 3); 
....................    } 
....................  
....................    return(ret); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_extended_id 
.................... // 
.................... // reads the extended identification of a buffer 
.................... // 
.................... // Parameters: 
.................... //      addr - the address that is to be read 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_extended_id(unsigned int *addr) 
.................... { 
....................    unsigned int32 ret; 
....................  
....................    ret=*addr;  //eidl 
....................  
....................    addr--;     //eidh 
....................    ret|=((unsigned int32)*addr << 8); 
....................  
....................    addr--;     //sidl 
....................    ret|=((unsigned int32)*addr & 0x03) << 16; 
....................    ret|=((unsigned int32)*addr & 0xE0) << 13; 
....................  
....................    addr--;     //sidh 
....................    ret|=((unsigned int32)*addr << 21); 
....................  
....................    return (ret); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_get_standard_id 
.................... // 
.................... // reads the standard identification of a buffer 
.................... // 
.................... // Parameters 
.................... //      addr - the address that is to be read 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... unsigned int32 can_get_standard_id(unsigned int *addr) 
.................... { 
....................    unsigned int32 ret; 
....................  
....................    addr-=2;    //sidl 
....................    ret=((unsigned int32)*addr & 0xE0) >> 5; 
....................  
....................    addr--;     //sidh 
....................    ret|=((unsigned int32)*addr << 3); 
....................  
....................    return (ret); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_putd() 
.................... // 
.................... // Puts data on a transmit buffer, at which time the CAN peripheral will 
.................... // send when the CAN bus becomes available. 
.................... // 
.................... //    Parameters: 
.................... //       id - ID to transmit data as 
.................... //          enumerated as - RXB0ID,RXB1ID,B0ID,B1ID,B2ID,B3ID,B4ID,B5ID 
.................... //       data - pointer to data to send 
.................... //       len - length of data to send 
.................... //       priority - priority of message.  The higher the number, the 
.................... //                  sooner the CAN peripheral will send the message. 
.................... //                  Numbers 0 through 3 are valid. 
.................... //       ext - TRUE to use an extended ID, FALSE if not 
.................... //       rtr - TRUE to set the RTR (request) bit in the ID, false if NOT 
.................... // 
.................... //    Returns: 
.................... //       If successful, it will return TRUE 
.................... //       If un-successful, will return FALSE 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int priority, int1 ext, int1 rtr) { 
....................    unsigned int i; 
....................    unsigned int *txd0; 
....................    unsigned int port; 
....................  
....................    txd0=&TXRXBaD0; 
*
0316:  MOVLW  0F
0318:  MOVWF  18
031A:  MOVLW  66
031C:  MOVWF  17
....................  
....................     // find empty transmitter 
....................     // map access bank addresses to empty transmitter 
....................    if (!TXB0CON.txreq) 
031E:  MOVLB  F
0320:  BTFSC  x20.3
0322:  BRA    033E
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
0324:  MOVF   05,F
0326:  BNZ   0332
....................          CANCON.win=CAN_WIN_TX0; 
0328:  MOVLW  F1
032A:  ANDWF  F6F,W
032C:  IORLW  08
032E:  MOVWF  F6F
0330:  BRA    033A
....................       else 
....................          ECANCON.ewin=TX0; 
0332:  MOVLW  E0
0334:  ANDWF  F72,W
0336:  IORLW  03
0338:  MOVWF  F72
....................       port=0; 
033A:  CLRF   19
....................    } 
033C:  BRA    040C
....................    else if (!TXB1CON.txreq) 
033E:  BTFSC  x10.3
0340:  BRA    035E
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
0342:  MOVF   05,F
0344:  BNZ   0350
....................          CANCON.win=CAN_WIN_TX1; 
0346:  MOVLW  F1
0348:  ANDWF  F6F,W
034A:  IORLW  06
034C:  MOVWF  F6F
034E:  BRA    0358
....................       else 
....................          ECANCON.ewin=TX1; 
0350:  MOVLW  E0
0352:  ANDWF  F72,W
0354:  IORLW  04
0356:  MOVWF  F72
....................       port=1; 
0358:  MOVLW  01
035A:  MOVWF  19
....................    } 
035C:  BRA    040C
....................    else if (!TXB2CON.txreq) 
035E:  BTFSC  x00.3
0360:  BRA    037E
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
0362:  MOVF   05,F
0364:  BNZ   0370
....................          CANCON.win=CAN_WIN_TX2; 
0366:  MOVLW  F1
0368:  ANDWF  F6F,W
036A:  IORLW  04
036C:  MOVWF  F6F
036E:  BRA    0378
....................       else 
....................          ECANCON.ewin=TX2; 
0370:  MOVLW  E0
0372:  ANDWF  F72,W
0374:  IORLW  05
0376:  MOVWF  F72
....................       port=2; 
0378:  MOVLW  02
037A:  MOVWF  19
....................    } 
037C:  BRA    040C
....................    else if (!B0CONT.txreq && BSEL0.b0txen) 
037E:  MOVLB  E
0380:  BTFSC  x80.3
0382:  BRA    0396
0384:  BTFSS  x7D.2
0386:  BRA    0396
....................    { 
....................       ECANCON.ewin=TXRX0; 
0388:  MOVLW  E0
038A:  ANDWF  F72,W
038C:  IORLW  12
038E:  MOVWF  F72
....................       port=3; 
0390:  MOVLW  03
0392:  MOVWF  19
....................    } 
0394:  BRA    040A
....................    else if (!B1CONT.txreq && BSEL0.b1txen) 
0396:  BTFSC  x90.3
0398:  BRA    03AC
039A:  BTFSS  x7D.3
039C:  BRA    03AC
....................    { 
....................       ECANCON.ewin=TXRX1; 
039E:  MOVLW  E0
03A0:  ANDWF  F72,W
03A2:  IORLW  13
03A4:  MOVWF  F72
....................       port=4; 
03A6:  MOVLW  04
03A8:  MOVWF  19
....................    } 
03AA:  BRA    040A
....................    else if (!B2CONT.txreq && BSEL0.b2txen) 
03AC:  BTFSC  xA0.3
03AE:  BRA    03C2
03B0:  BTFSS  x7D.4
03B2:  BRA    03C2
....................    { 
....................       ECANCON.ewin=TXRX2; 
03B4:  MOVLW  E0
03B6:  ANDWF  F72,W
03B8:  IORLW  14
03BA:  MOVWF  F72
....................       port=5; 
03BC:  MOVLW  05
03BE:  MOVWF  19
....................    } 
03C0:  BRA    040A
....................    else if (!B3CONT.txreq && BSEL0.b3txen) 
03C2:  BTFSC  xB0.3
03C4:  BRA    03D8
03C6:  BTFSS  x7D.5
03C8:  BRA    03D8
....................    { 
....................       ECANCON.ewin=TXRX3; 
03CA:  MOVLW  E0
03CC:  ANDWF  F72,W
03CE:  IORLW  15
03D0:  MOVWF  F72
....................       port=6; 
03D2:  MOVLW  06
03D4:  MOVWF  19
....................    } 
03D6:  BRA    040A
....................    else if (!B4CONT.txreq && BSEL0.b4txen) 
03D8:  BTFSC  xC0.3
03DA:  BRA    03EE
03DC:  BTFSS  x7D.6
03DE:  BRA    03EE
....................    { 
....................       ECANCON.ewin=TXRX4; 
03E0:  MOVLW  E0
03E2:  ANDWF  F72,W
03E4:  IORLW  16
03E6:  MOVWF  F72
....................       port=7; 
03E8:  MOVLW  07
03EA:  MOVWF  19
....................    } 
03EC:  BRA    040A
....................    else if (!B5CONT.txreq && BSEL0.b5txen) 
03EE:  BTFSC  xD0.3
03F0:  BRA    0404
03F2:  BTFSS  x7D.7
03F4:  BRA    0404
....................    { 
....................       ECANCON.ewin=TXRX5; 
03F6:  MOVLW  E0
03F8:  ANDWF  F72,W
03FA:  IORLW  17
03FC:  MOVWF  F72
....................       port=8; 
03FE:  MOVLW  08
0400:  MOVWF  19
....................    } 
0402:  BRA    040A
....................    else 
....................    { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nCAN_PUTD() FAIL: NO OPEN TX BUFFERS\r\n"); 
....................       #endif 
....................       return(0); 
0404:  MOVLW  00
0406:  MOVWF  01
0408:  BRA    0490
040A:  MOVLB  F
....................    } 
....................  
....................    //set priority. 
....................    TXBaCON.txpri=priority; 
040C:  MOVF   13,W
040E:  ANDLW  03
0410:  MOVWF  00
0412:  MOVLW  FC
0414:  ANDWF  F60,W
0416:  IORWF  00,W
0418:  MOVWF  F60
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
041A:  MOVLW  0F
041C:  MOVWF  1B
041E:  MOVLW  64
0420:  MOVWF  1A
0422:  MOVFF  0F,1F
0426:  MOVFF  0E,1E
042A:  MOVFF  0D,1D
042E:  MOVFF  0C,1C
0432:  MOVFF  14,20
0436:  MOVLB  0
0438:  RCALL  0058
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
043A:  MOVFF  12,F65
....................    TXBaDLC.rtr=rtr; 
043E:  BCF    F65.6
0440:  BTFSC  15.0
0442:  BSF    F65.6
....................  
....................     for (i=0; i<len; i++) { 
0444:  CLRF   16
0446:  MOVF   12,W
0448:  SUBWF  16,W
044A:  BC    0474
....................       *txd0=*data; 
044C:  MOVFF  10,FE9
0450:  MOVFF  11,FEA
0454:  MOVFF  FEF,1C
0458:  MOVFF  18,FEA
045C:  MOVFF  17,FE9
0460:  MOVFF  1C,FEF
....................       txd0++; 
0464:  INCF   17,F
0466:  BTFSC  FD8.2
0468:  INCF   18,F
....................       data++; 
046A:  INCF   10,F
046C:  BTFSC  FD8.2
046E:  INCF   11,F
0470:  INCF   16,F
0472:  BRA    0446
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
0474:  BSF    F60.3
....................  
....................    if(curfunmode==CAN_FUN_OP_LEGACY) 
0476:  MOVF   05,F
0478:  BNZ   0482
....................       CANCON.win=CAN_WIN_RX0; 
047A:  MOVLW  F1
047C:  ANDWF  F6F,W
047E:  MOVWF  F6F
0480:  BRA    048A
....................    else 
....................       ECANCON.ewin=RX0; 
0482:  MOVLW  E0
0484:  ANDWF  F72,W
0486:  IORLW  10
0488:  MOVWF  F72
....................  
....................    #if CAN_DO_DEBUG 
....................             can_debug("\r\nCAN_PUTD(): BUFF=%U ID=%LX LEN=%U PRI=%U EXT=%U RTR=%U\r\n", port, id, len, priority, ext, rtr); 
....................             if ((len)&&(!rtr)) { 
....................                data-=len; 
....................                can_debug("  DATA = "); 
....................                for (i=0;i<len;i++) { 
....................                   can_debug("%X ",*data); 
....................                   data++; 
....................                } 
....................                can_debug("\r\n"); 
....................             } 
....................    #endif 
....................  
....................    return(1); 
048A:  MOVLW  01
048C:  MOVWF  01
048E:  MOVLB  E
0490:  MOVLB  0
0492:  GOTO   0514 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_getd() 
.................... // 
.................... // Gets data from a receive buffer, if the data exists 
.................... // 
.................... //    Parameters: 
.................... //      id - ID who sent message 
.................... //      data - pointer to array of data 
.................... //      len - length of received data 
.................... //      stat - structure holding some information (such as which buffer 
.................... //             received it, ext or standard, etc) 
.................... // 
.................... //    Returns: 
.................... //      Function call returns a TRUE if there was data in a RX buffer, FALSE 
.................... //      if there was none. 
.................... // 
.................... //////////////////////////////////////////////////////////////////////// 
.................... int1 can_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat) 
.................... { 
....................    unsigned int i; 
....................    unsigned int *ptr; 
....................  
....................    if (RXB0CON.rxful) 
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
....................          CANCON.win=CAN_WIN_RX0; 
....................       else 
....................          ECANCON.ewin=RX0;          // this is if in functional mode 1 or 2 
....................  
....................       stat.buffer=0; 
....................  
....................       //CAN_INT_RXB0IF=0;           // moved to end of function 
....................  
....................       if(curfunmode) 
....................       { 
....................          stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................          COMSTAT_MODE_1.rxnovfl = 0; 
....................          stat.filthit=RXB0CON_MODE_1.filthit; 
....................       } 
....................       else 
....................       { 
....................          stat.err_ovfl=COMSTAT.rx0ovfl; 
....................          COMSTAT.rx0ovfl=0; 
....................  
....................          if (RXB0CON.rxb0dben) 
....................          { 
....................             stat.filthit=RXB0CON.filthit0; 
....................          } 
....................       } 
....................    } 
....................    else if ( RXB1CON.rxful ) 
....................    { 
....................       if(curfunmode==CAN_FUN_OP_LEGACY) 
....................          CANCON.win=CAN_WIN_RX1; 
....................       else 
....................          ECANCON.ewin=RX1; 
....................  
....................       stat.buffer=1; 
....................  
....................       //CAN_INT_RXB1IF=0;           //moved to end of function 
....................  
....................       if(curfunmode) 
....................       { 
....................          stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................          COMSTAT_MODE_1.rxnovfl = 0; 
....................          stat.filthit=RXB1CON_MODE_1.filthit; 
....................       } 
....................       else 
....................       { 
....................          stat.err_ovfl=COMSTAT.rx1ovfl; 
....................          COMSTAT.rx1ovfl=0; 
....................  
....................          stat.filthit=RXB1CON.filthit; 
....................       } 
....................    } 
....................    else if (B0CONR.rxful && !BSEL0.b0txen) 
....................    { 
....................       ECANCON.ewin=TXRX0; 
....................       stat.buffer=2; 
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................       COMSTAT_MODE_1.rxnovfl = 0; 
....................       stat.filthit=B0CONR.filhit; 
....................  
....................      // B0CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
....................    else if (B1CONR.rxful && !BSEL0.b1txen) 
....................    { 
....................       ECANCON.ewin=TXRX1; 
....................       stat.buffer=3; 
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................       COMSTAT_MODE_1.rxnovfl = 0; 
....................       stat.filthit=B1CONR.filhit; 
....................  
....................       //B1CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
....................    else if (B2CONR.rxful && !BSEL0.b2txen) 
....................    { 
....................       ECANCON.ewin=TXRX2; 
....................       stat.buffer=4; 
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................       COMSTAT_MODE_1.rxnovfl = 0; 
....................       stat.filthit=B2CONR.filhit; 
....................  
....................       //B2CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
....................    else if (B3CONR.rxful && !BSEL0.b3txen) 
....................    { 
....................       ECANCON.ewin=TXRX3; 
....................       stat.buffer=5; 
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................       COMSTAT_MODE_1.rxnovfl = 0; 
....................       stat.filthit=B3CONR.filhit; 
....................  
....................       //B3CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
....................    else if (B4CONR.rxful && !BSEL0.b4txen) 
....................    { 
....................       ECANCON.ewin=TXRX4; 
....................       stat.buffer=6; 
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................       COMSTAT_MODE_1.rxnovfl = 0; 
....................       stat.filthit=B4CONR.filhit; 
....................  
....................       //B4CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
....................    else if (B5CONR.rxful && !BSEL0.b5txen) 
....................    { 
....................       ECANCON.ewin=TXRX5; 
....................       stat.buffer=7; 
....................  
....................       //CAN_INT_RXB1IF=0;         //moved to end of function 
....................  
....................       stat.err_ovfl=COMSTAT_MODE_1.rxnovfl; 
....................       COMSTAT_MODE_1.rxnovfl = 0; 
....................       stat.filthit=B5CONR.filhit; 
....................  
....................       //B5CONR.rxful=0;          //moved to end of function because this shouldn't be 
....................                                  //cleared until after data has been retrieved from buffer 
....................    } 
....................    else 
....................    { 
....................       #if CAN_DO_DEBUG 
....................          can_debug("\r\nFAIL ON CAN_GETD(): NO MESSAGE IN BUFFER\r\n"); 
....................       #endif 
....................       return (0); 
....................    } 
....................  
....................    len = RXBaDLC.dlc; 
....................    stat.rtr=RXBaDLC.rtr; 
....................  
....................    stat.ext=TXRXBaSIDL.ext; 
....................    id=can_get_id(TXRXBaID,stat.ext); 
....................  
....................    ptr = &TXRXBaD0; 
....................    for ( i = 0; i < len; i++ ) 
....................    { 
....................       *data = *ptr; 
....................       data++; 
....................       ptr++; 
....................    } 
....................  
....................    switch(stat.buffer)     //switch statement to clear rxful flag and interrupt flag 
....................    { 
....................       case 0: 
....................          RXB0CON.rxful=0; 
....................          if(curfunmode) 
....................             CAN_INT_RXB1IF=0; 
....................          else 
....................             CAN_INT_RXB0IF=0; 
....................          break; 
....................       case 1: 
....................          RXB1CON.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................       case 2: 
....................          B0CONR.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................       case 3: 
....................          B1CONR.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................       case 4: 
....................          B2CONR.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................       case 5: 
....................          B3CONR.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................       case 6: 
....................          B4CONR.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................       case 7: 
....................          B5CONR.rxful=0; 
....................          CAN_INT_RXB1IF=0; 
....................          break; 
....................    } 
....................  
....................    stat.inv=CAN_INT_IRXIF; 
....................    CAN_INT_IRXIF = 0; 
....................  
....................    // return to default addressing 
....................    if(curfunmode==CAN_FUN_OP_LEGACY) 
....................       CANCON.win=CAN_WIN_RX0; 
....................    else 
....................       ECANCON.ewin=RX0; 
....................  
....................    #if CAN_DO_DEBUG 
....................       can_debug("\r\nCAN_GETD(): BUFF=%U ID=%LX LEN=%U OVF=%U ", stat.buffer, id, len, stat.err_ovfl); 
....................       can_debug("FILT=%U RTR=%U EXT=%U INV=%U", stat.filthit, stat.rtr, stat.ext, stat.inv); 
....................       if ((len)&&(!stat.rtr)) 
....................       { 
....................          data-=len; 
....................          can_debug("\r\n    DATA = "); 
....................          for (i=0;i<len;i++) 
....................          { 
....................             can_debug("%X ",*data); 
....................             data++; 
....................          } 
....................       } 
....................       can_debug("\r\n"); 
....................    #endif 
....................  
....................    return(1); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_b_transfer: mode 1 & 2 
.................... // 
.................... // Sets one of the 6 programmable buffers to be a transfer buffer.  This uses 
.................... // a simple bitwise operation so that more than one buffer can be set at a 
.................... // time. 
.................... // 
.................... // The register that contains the TX/RX information is BSEL0 and the control 
.................... //   bits take up the 6 most significant bits.  Therefore a value of 0x04 would 
.................... //   set B0 as a transmit buffer while a value of 0xFC would set all of the 
.................... // programmable buffers to transmit buffers. 
.................... // 
.................... //   Parameters: 
.................... //      b - the buffer which is to become a transfer buffer 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... // 
.................... // More information can be found on the programmable buffers in the PIC18F4580 
.................... //   datasheet, section 23.5.3 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_enable_b_transfer(PROG_BUFFER b) 
.................... { 
....................    unsigned int8 temp; 
....................  
....................    temp=BSEL0; 
....................    temp|=b; 
....................  
....................    BSEL0=temp; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_b_receiver: mode 1 & 2 
.................... // 
.................... // Sets one of the 6 programmable buffers to be a receiver buffer.  This uses 
.................... // a simple bitwise operation so that more than one buffer can be set at a 
.................... // time. 
.................... // 
.................... // The register that contains the TX/RX information is BSEL0 and the control 
.................... //   bits take up the 6 most significant bits.  Therefore a value of 0x04 would 
.................... //   set B0 as a receive buffer while a value of 0xFC would set all of the 
.................... // programmable buffers to receive buffers. 
.................... // 
.................... // Parameters: 
.................... //    b - the buffer which is to become a receiver buffer 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... // 
.................... // returns: 
.................... //      void 
.................... // 
.................... // More information can be found on the programmable buffers in the PIC18F4580 
.................... // datasheet, section 23.5.3 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_enable_b_receiver(PROG_BUFFER b) 
.................... { 
....................    unsigned int8 temp; 
....................  
....................    temp=BSEL0; 
....................    temp&=~b; 
....................  
....................    BSEL0=temp; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_rtr: mode 1 & 2 
.................... // 
.................... // Prepares one of the programmable registers to be used as an Auto-rtr buffer 
.................... //   This function allows for multiple rtr enables. 
.................... // 
.................... // Parameters: 
.................... //      b - the programmable buffer to be set to Auto-rtr mode 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... // 
.................... //      b=0x04 - B0 rtr enable 
.................... //      b=0x08 - B1 rtr enable 
.................... //      b=0x10 - B2 rtr enable 
.................... //      b=0x20 - B3 rtr enable 
.................... //    b=0x40 - B4 rtr enable 
.................... //      b=0x80 -   B5 rtr enable 
.................... // 
.................... //      any logical and (&) combination of the above will also work 
.................... // 
.................... //      b = 0x04 & 0x80 = 0x84 - B0 and B5 rtr enable 
.................... // 
.................... // returns: 
.................... //     void 
.................... // 
.................... // More information can be found on Auto-rtr in the PIC18F4580 datasheet, 
.................... //   section 23.5.4 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_enable_rtr(PROG_BUFFER b) 
.................... { 
....................  
....................    can_enable_b_transfer ( b ); 
....................  
....................    if(bit_test(b,2)) 
....................       B0CONTA|=0x04; 
....................    if(bit_test(b,3)) 
....................       B1CONTA|=0x04; 
....................    if(bit_test(b,4)) 
....................       B2CONTA|=0x04; 
....................    if(bit_test(b,5)) 
....................       B3CONTA|=0x04; 
....................    if(bit_test(b,6)) 
....................       B4CONTA|=0x04; 
....................    if(bit_test(b,7)) 
....................       B5CONTA|=0x04; 
....................  
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_rtr: mode 1 & 2 
.................... // 
.................... // disables certain programmable registers from being used as Auto-rtr buffers 
.................... //   This function allows for multiple rtr disables. 
.................... // 
.................... // Parameters: 
.................... //      b - the programmable buffer to be set to Auto-rtr mode 
.................... //       enumerated as B0,B1,B2,B3,B4,B5 
.................... // 
.................... //      b=0x04 - B0 rtr disable 
.................... //      b=0x08 - B1 rtr disable 
.................... //      b=0x10 - B2 rtr disable 
.................... //      b=0x20 - B3 rtr disable 
.................... //    b=0x40 - B4 rtr disable 
.................... //      b=0x80 -   B5 rtr disable 
.................... // 
.................... //      any logical or (|) combination of the above will also work 
.................... // 
.................... //      b = 0x04 | 0x80 = 0x84 - B0 and B5 rtr disable 
.................... // 
.................... // returns: 
.................... //     void 
.................... // 
.................... // More information can be found on Auto-rtr in the PIC18F4580 datasheet, 
.................... //   section 23.5.4 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void can_disable_rtr(PROG_BUFFER b) 
.................... { 
....................    if(bit_test(b,2)) 
....................       B0CONTA&=0xfb; 
....................    if(bit_test(b,3)) 
....................       B1CONTA&=0xfb; 
....................    if(bit_test(b,4)) 
....................       B2CONTA&=0xfb; 
....................    if(bit_test(b,5)) 
....................       B3CONTA&=0xfb; 
....................    if(bit_test(b,6)) 
....................       B4CONTA&=0xfb; 
....................    if(bit_test(b,7)) 
....................       B5CONTA&=0xfb; 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_load_rtr: mode 1 & 2 
.................... // 
.................... //   Loads a SINGLE b buffer with data to be sent on the occurrence of an rtr. 
.................... // 
.................... // Parameters: 
.................... // 
.................... //      b - The programmable buffer to be filled 
.................... //       enumerated as - B0,B1,B2,B3,B4,B5 
.................... //      data - the address of the first data byte 
.................... //      len - the number of data bytes to be copied 
.................... // 
.................... // Returns: 
.................... //      void 
.................... // 
.................... //   Note, the programmer must set the appropriate rtr registers in order for the 
.................... //         rtr function to work.  This function does not set any of those 
.................... //         registers.  For example, to enable B0 as an Auto-rtr buffer, the 
.................... //         functions: 
.................... // 
.................... //         can_enable_b_transfer(B0); 
.................... //         can_enable_rtr(B0); 
.................... //         function to link acceptance filter to B0 
.................... // 
.................... //         need to be called. 
.................... // 
.................... //   can_load_rtr does no damage to the current mode of the ECAN 
.................... // 
.................... // More information on the Auto-rtr can be found in the PIC18F4580 datasheet 
.................... // section 23.5.4 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_load_rtr (PROG_BUFFER b, unsigned int *data, unsigned int len) 
.................... { 
....................  
....................    unsigned int *ptr; 
....................  
....................    //do no damage to the current mode; 
....................    curmode = CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    if(bit_test(b,2)) 
....................    { 
....................       ptr=&B0D0; 
....................       B0DLCT=len; 
....................    } 
....................    else if (bit_test(b,3)) 
....................    { 
....................       ptr=&B1D0; 
....................       B1DLCT=len; 
....................    } 
....................    else if (bit_test(b,4)) 
....................    { 
....................       ptr=&B2D0; 
....................       B2DLCT=len; 
....................    } 
....................    else if (bit_test(b,5)) 
....................    { 
....................       ptr=&B3D0; 
....................       B3DLCT=len; 
....................    } 
....................    else if (bit_test(b,6)) 
....................    { 
....................       ptr=&B4D0; 
....................       B4DLCT=len; 
....................    } 
....................    else if (bit_test(b,7)) 
....................    { 
....................       ptr=&B5D0; 
....................       B5DLCT=len; 
....................    } 
....................    else 
....................       return; 
....................  
....................    for(;len>0;len--) { 
....................       *ptr=*data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_enable_filter: mode 1 , 2 & 3 
.................... // 
.................... //   Enables a given acceptance filter 
.................... // 
.................... // Parameters: 
.................... //      filter - the filter that is to be enabled 
.................... //         enumerated as - RXF0EN-RXF15EN 
.................... // 
.................... // Returns: 
.................... //    void 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_enable_filter(unsigned long filter) 
.................... { 
....................    unsigned long *ptr; 
....................  
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &RXFCON0; 
....................  
....................    *ptr|=filter; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_disable_filter: mode 0 , 1 & 2 
.................... // 
.................... // Disables a given acceptance filter 
.................... // 
.................... // Parameters: 
.................... //      filter - the filter that is to be disabled 
.................... //        enumerated as - RXF0EN-RXF15EN 
.................... // 
.................... // Returns: 
.................... //      void; 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_disable_filter(unsigned long filter) 
.................... { 
....................    unsigned long *ptr; 
....................  
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &RXFCON0; 
....................  
....................    *ptr&=~filter; 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_associate_filter_to_buffer: mode 1 & 2 
.................... // 
.................... // Associates a given buffer with a given filter register 
.................... // 
.................... // Parameters: 
.................... //      buffer - the buffer that is to be associated with the filter 
.................... //        enumerated as 
.................... //               ARXB0-ARXB1 - Dedicated receive buffers RX0-RX1 
.................... //               AB0-AB5 - Programmable receive buffers B0-B5 
.................... // 
.................... //      filter - the filter that is to be associated with the buffer 
.................... //         enumerated as 
.................... //               F0BP-F15BP - Filters 0 - 15 
.................... // 
.................... // 
.................... // Returns: 
.................... //      void 
.................... // 
.................... //   More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_associate_filter_to_buffer(CAN_FILTER_ASSOCIATION_BUFFERS buffer, CAN_FILTER_ASSOCIATION filter) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    curmode=CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &RXFBCON0 + (filter >> 1); 
....................  
....................    if((filter & 0x01) == 1) 
....................    { 
....................       *ptr&=0x0f; 
....................       *ptr|=buffer<<4; 
....................    } 
....................    else 
....................    { 
....................       *ptr&=0xf0; 
....................       *ptr|=buffer; 
....................    } 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_associate_filter_to_mask 
.................... // 
.................... //   Associates a given filter to a given mask 
.................... // 
.................... //   Parameters: 
.................... //      mask - the mask that is to be associated with the filter 
.................... //         enumerated as 
.................... //            ACCEPTANCE_MASK_0 
.................... //            ACCEPTANCE_MASK_1 
.................... //            FILTER_15 
.................... //            NO_MASK 
.................... // 
.................... //      filter - the filter that is to be associated with the mask 
.................... //         enumerated as 
.................... //               F0BP-F15BP - Filters 0 - 15 
.................... // 
.................... // 
.................... //   Returns: 
.................... //      void 
.................... // 
.................... // More information can be found on Acceptance Filters in the PIC18F4580 
.................... // datasheet, Section 23.8 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... void can_associate_filter_to_mask(CAN_MASK_FILTER_ASSOCIATE mask, CAN_FILTER_ASSOCIATION filter) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    curmode = CANSTAT.opmode; 
....................  
....................    can_set_mode(CAN_OP_CONFIG); 
....................  
....................    ptr = &MSEL0 + (filter >> 2); 
....................  
....................    if((filter & 0x03)==0) 
....................    { 
....................       *ptr&=0xfc; 
....................       *ptr|=mask; 
....................    } 
....................    else if((filter & 0x03)==1) 
....................    { 
....................       *ptr&=0xf3; 
....................       *ptr|=mask<<2; 
....................    } 
....................    else if((filter & 0x03)==2) 
....................    { 
....................       *ptr&=0xcf; 
....................       *ptr|=mask<<4; 
....................    } 
....................    else if((filter & 0x03)==3) 
....................    { 
....................       *ptr&=0x3f; 
....................       *ptr|=mask<<6; 
....................    } 
....................  
....................    can_set_mode(curmode); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_FIFO_getd 
.................... // 
.................... // Retrieves data in Mode 2 
.................... // 
.................... // Parameters: 
.................... //      id - The ID of the sender 
.................... //      data - Address of the array to store the data in 
.................... //      len - number of data bytes to read 
.................... //      stat - status structure to return information about the receive register 
.................... // 
.................... // Returns: 
.................... //      int1 - TRUE if there was data in the buffer, FALSE if there wasn't 
.................... // 
.................... // More information can be found on the FIFO mode in the PIC18F4580 datasheet 
.................... // section 23.7.3 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... int1 can_fifo_getd(unsigned int32 &id, unsigned int *data, unsigned int &len, struct rx_stat &stat ) 
.................... { 
....................  
....................    unsigned int i; 
....................    unsigned int *ptr; 
....................  
....................    if(!COMSTAT_MODE_2.fifoempty)          // if there is no data in the buffer 
....................       return(0);                          // return false; 
....................  
....................    ECANCON.ewin=CANCON_MODE_2.fp | 0x10; 
....................    stat.buffer=CANCON_MODE_2.fp; 
....................  
....................    //CAN_INT_RXB1IF=0;                    // moved to end of function 
....................  
....................    stat.err_ovfl=COMSTAT_MODE_2.rxnovfl; 
....................    COMSTAT_MODE_2.rxnovfl = 0; 
....................    stat.filthit=RXB0CON_MODE_2.filthit; 
....................  
....................    len = RXBaDLC.dlc; 
....................    stat.rtr=RXBaDLC.rtr; 
....................  
....................    stat.ext=TXRXBaSIDL.ext; 
....................    id=can_get_id(TXRXBaID,stat.ext); 
....................  
....................    ptr = &TXRXBaD0; 
....................    for ( i = 0; i < len; i++ ) { 
....................        *data = *ptr; 
....................        data++; 
....................        ptr++; 
....................    } 
....................  
....................    RXB0CON_MODE_2.rxful=0; 
....................  
....................    CAN_INT_RXB1IF=0; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    stat.inv=CAN_INT_IRXIF; 
....................    CAN_INT_IRXIF = 0; 
....................  
....................    return(1); 
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... // 
.................... // can_t0_putd - can_t2_putd 
.................... // can_b0_putd - can_b5_putd 
.................... // 
.................... // places data to be transferred in a specified buffer 
.................... // 
.................... // Parameters: 
.................... //      id - id that will be sent with the data 
.................... //    data - pointer to the data 
.................... //      len - number of data bytes (0-8) 
.................... //      pri - priority (0-3) 
.................... //      ext - extended or not 
.................... //    rtr - request remote transfer 
.................... // 
.................... // Returns: 
.................... //      TRUE if data is successfully loaded into the buffer 
.................... //      FALSE if data can not be loaded into the buffer 
.................... // 
.................... //   Notes 
.................... //      - make sure that the desired buffer is set to be a transfer buffer 
.................... //        using the can_enable_b_transfer ( ) function 
.................... // 
.................... // More information can be found on using the transfer buffers in the PICF4580 
.................... //   datasheet section 23.6 
.................... // 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // transfer buffer 0 
.................... int1 can_t0_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    if(TXB0CON.txreq) 
....................       return ( FALSE ); 
....................  
....................    can_set_id( TXB0ID, id, ext ); 
....................  
....................    TXB0DLC.dlc = len; 
....................  
....................    TXB0CON.txpri = pri; 
....................  
....................    TXB0DLC.rtr = rtr; 
....................  
....................    ptr = &TXB0D0; 
....................  
....................    for(;len>0;len--) 
....................    { 
....................       *ptr = *data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    TXB0CON.txreq = 1; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // transfer buffer 1 
.................... int1 can_t1_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    if(TXB1CON.txreq) 
....................       return ( FALSE ); 
....................  
....................    can_set_id( TXB1ID, id, ext ); 
....................  
....................    TXB1DLC.dlc = len; 
....................  
....................    TXB1CON.txpri = pri; 
....................  
....................    TXB1DLC.rtr = rtr; 
....................  
....................    ptr = &TXB1D0; 
....................  
....................    for(;len>0;len--) 
....................    { 
....................       *ptr = *data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    TXB1CON.txreq = 1; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // transfer buffer 2 
.................... int1 can_t2_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *ptr; 
....................  
....................    if(TXB2CON.txreq) 
....................       return ( FALSE ); 
....................  
....................    can_set_id( TXB2ID, id, ext ); 
....................  
....................    TXB2DLC.dlc = len; 
....................  
....................    TXB2CON.txpri = pri; 
....................  
....................    TXB2DLC.rtr = rtr; 
....................  
....................    ptr = &TXB2D0; 
....................  
....................    for(;len>0;len--) 
....................    { 
....................       *ptr = *data; 
....................       ptr++; 
....................       data++; 
....................    } 
....................  
....................    TXB2CON.txreq = 1; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 0 
.................... int1 can_b0_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B0CONT.txreq || !BSEL0.b0txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX0; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
....................  
.................... } 
....................  
.................... // programmable buffer 1 
.................... int1 can_b1_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B1CONT.txreq || !BSEL0.b1txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX1; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 2 
.................... int1 can_b2_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B2CONT.txreq || !BSEL0.b2txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX2; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 3 
.................... int1 can_b3_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B3CONT.txreq || !BSEL0.b3txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX3; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
....................  
.................... } 
....................  
.................... // programmable buffer 4 
.................... int1 can_b4_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B4CONT.txreq || !BSEL0.b4txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX4; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................     for (;len>0;len--) 
....................     { 
....................       *txd0=*data; 
....................       txd0++; 
....................       data++; 
....................     } 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
.................... // programmable buffer 5 
.................... int1 can_b5_putd(unsigned int32 id, unsigned int *data, unsigned int len, unsigned int pri, int1 ext, int1 rtr) 
.................... { 
....................    unsigned int *txd0; 
....................  
....................    txd0=&TXRXBaD0; 
....................  
....................    if (B5CONT.txreq || !BSEL0.b5txen) 
....................       return ( FALSE ); 
....................  
....................    ECANCON.ewin=TXRX5; 
....................  
....................     //set priority. 
....................    TXBaCON.txpri=pri; 
....................  
....................    //set tx mask 
....................    can_set_id(TXRXBaID, id, ext); 
....................  
....................    //set tx data count 
....................    TXBaDLC=len; 
....................    TXBaDLC.rtr=rtr; 
....................  
....................    for (;len>0;len--) 
....................    { 
....................      *txd0=*data; 
....................      txd0++; 
....................      data++; 
....................    } 
....................  
....................    txd0=&B5D0; 
....................  
....................    //enable transmission 
....................    TXBaCON.txreq=1; 
....................  
....................    // return to default addressing 
....................    ECANCON.ewin=RX0; 
....................  
....................    return ( TRUE ); 
.................... } 
....................  
....................  
....................  
.................... #define PIN_LED1  PIN_A2 
.................... #define PIN_LED2  PIN_A1 
....................  
.................... #define LED1_LOW  output_low(PIN_LED1) 
.................... #define LED1_HIGH output_high(PIN_LED1) 
.................... #define LED2_LOW  output_low(PIN_LED2) 
.................... #define LED2_HIGH output_high(PIN_LED2) 
....................  
.................... #define WRITE_REGISTER_D_ID      0x100  //CAN bus ID. 
....................  
.................... //Variable bus CAN 
.................... //int32 rx_id; 
.................... //int rx_len; 
.................... struct rx_stat stat; 
.................... unsigned int buf[2]; 
....................  
.................... void main ( ) 
*
04BE:  CLRF   FF8
04C0:  BCF    FD0.7
04C2:  MOVLW  70
04C4:  MOVWF  FD3
04C6:  MOVLW  40
04C8:  MOVWF  F9B
04CA:  CLRF   F64
04CC:  MOVLB  F
04CE:  MOVF   x5C,W
04D0:  ANDLW  80
04D2:  MOVWF  x5C
04D4:  MOVLW  00
04D6:  MOVWF  x5D
04D8:  BCF    FC1.3
04DA:  BCF    FC1.4
04DC:  BCF    FC1.5
04DE:  CLRF   x5E
04E0:  CLRF   x5F
.................... { 
....................  
....................     //Send data. 
....................     buf[0] = 0x24; 
04E2:  MOVLW  24
04E4:  MOVWF  0A
....................     buf[1] = 0x14; 
04E6:  MOVLW  14
04E8:  MOVWF  0B
....................      
....................     can_init(); // Initialize the can 
04EA:  MOVLB  0
04EC:  BRA    0180
....................      
....................     while(1) { 
....................         LED2_HIGH; 
04EE:  BCF    F92.1
04F0:  BSF    F89.1
....................         LED1_LOW; 
04F2:  BCF    F92.2
04F4:  BCF    F89.2
....................         can_putd(WRITE_REGISTER_D_ID,&buf,sizeof(buf),1,FALSE,FALSE);  
04F6:  CLRF   0F
04F8:  CLRF   0E
04FA:  MOVLW  01
04FC:  MOVWF  0D
04FE:  CLRF   0C
0500:  CLRF   11
0502:  MOVLW  0A
0504:  MOVWF  10
0506:  MOVLW  02
0508:  MOVWF  12
050A:  MOVLW  01
050C:  MOVWF  13
050E:  CLRF   14
0510:  CLRF   15
0512:  BRA    0316
....................         /*  - Identifier: 0x100 
....................             - Data pointer: buf 
....................             - Number of data bytes: sizeof(buf) = 2 
....................             - Priority (0-3) determines the order messages are sent 
....................             - Flag to indicate 29 bit identifier 
....................             - Flag to indicate if this is a data frame 
....................     (       FALSE) or request for frame (TRUE) 
....................         */ 
....................         delay_ms(500); 
0514:  MOVLW  02
0516:  MOVWF  0C
0518:  MOVLW  FA
051A:  MOVWF  0D
051C:  RCALL  0496
051E:  DECFSZ 0C,F
0520:  BRA    0518
....................         LED1_HIGH; 
0522:  BCF    F92.2
0524:  BSF    F89.2
....................         LED2_LOW; 
0526:  BCF    F92.1
0528:  BCF    F89.1
....................         delay_ms(500); 
052A:  MOVLW  02
052C:  MOVWF  0C
052E:  MOVLW  FA
0530:  MOVWF  0D
0532:  RCALL  0496
0534:  DECFSZ 0C,F
0536:  BRA    052E
0538:  BRA    04EE
....................     } 
.................... } 
....................  
053A:  SLEEP 
....................  

Configuration Fuses:
   Word  1: C815   VREGSLEEP INTRC_HP SOSC_DIG NOXINST INTRC_IO NOPLLEN FCMEN IESO
   Word  2: 1C78   PUT NOBROWNOUT BORV18 ZPBORM NOWDT WDT128
   Word  3: 8900   CANB MSSPMSK7 MCLR
   Word  4: 0091   STVREN BBSIZ2K NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
